/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AIMindmapPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/services/contentAggregator.ts
var import_obsidian = require("obsidian");
var ContentAggregator = class {
  constructor(app) {
    this.app = app;
  }
  async processSelection(selection) {
    const processedContent = [];
    const processedFiles = /* @__PURE__ */ new Set();
    for (const filePath of selection.files) {
      if (!processedFiles.has(filePath)) {
        const content = await this.processFile(filePath);
        if (content) {
          processedContent.push(content);
          processedFiles.add(filePath);
        }
      }
    }
    for (const folderPath of selection.folders) {
      const folderFiles = await this.getFilesInFolder(folderPath, selection.includeSubfolders);
      for (const file of folderFiles) {
        if (!processedFiles.has(file.path)) {
          const content = await this.processFile(file.path);
          if (content) {
            processedContent.push(content);
            processedFiles.add(file.path);
          }
        }
      }
    }
    if (selection.tags.length > 0) {
      const taggedFiles = await this.getFilesByTags(selection.tags);
      for (const file of taggedFiles) {
        if (!processedFiles.has(file.path)) {
          const content = await this.processFile(file.path);
          if (content) {
            processedContent.push(content);
            processedFiles.add(file.path);
          }
        }
      }
    }
    return processedContent;
  }
  async processFile(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile)) {
      return null;
    }
    if (file.extension !== "md") {
      return null;
    }
    try {
      const content = await this.app.vault.read(file);
      const { frontmatter, body } = this.parseFrontmatter(content);
      return {
        title: frontmatter.title || file.basename,
        content: this.cleanContent(body),
        tags: this.extractTags(frontmatter, body),
        metadata: frontmatter,
        filePath: file.path
      };
    } catch (error) {
      console.error(`Error processing file ${filePath}:`, error);
      return null;
    }
  }
  parseFrontmatter(content) {
    const frontmatterRegex = /^---\s*\r?\n(.*?)\r?\n---\s*\r?\n(.*)/s;
    const match = content.match(frontmatterRegex);
    console.log("Parsing frontmatter, content start:", content.substring(0, 200));
    console.log("Frontmatter regex match:", !!match);
    if (match) {
      try {
        const frontmatterText = match[1];
        console.log("Frontmatter text:", frontmatterText);
        const frontmatter = {};
        const lines = frontmatterText.split(/\r?\n/);
        for (const line of lines) {
          const colonIndex = line.indexOf(":");
          if (colonIndex > 0) {
            const key = line.substring(0, colonIndex).trim();
            let valueText = line.substring(colonIndex + 1).trim();
            console.log(`Processing frontmatter line - key: "${key}", value: "${valueText}"`);
            let value;
            if (valueText.startsWith("[") && valueText.endsWith("]")) {
              value = valueText.slice(1, -1).split(",").map((v) => v.trim().replace(/['"]/g, ""));
            } else if (valueText.startsWith("-")) {
              value = [valueText.substring(1).trim().replace(/['"]/g, "")];
            } else {
              value = valueText.replace(/^['"]|['"]$/g, "");
            }
            frontmatter[key] = value;
          }
        }
        console.log("Parsed frontmatter:", frontmatter);
        return {
          frontmatter,
          body: match[2].trim()
        };
      } catch (error) {
        console.warn("Error parsing frontmatter:", error);
        return { frontmatter: {}, body: content };
      }
    }
    console.log("No frontmatter found in content");
    return { frontmatter: {}, body: content };
  }
  extractTags(frontmatter, body) {
    const tags = /* @__PURE__ */ new Set();
    if (frontmatter.tags) {
      if (Array.isArray(frontmatter.tags)) {
        frontmatter.tags.forEach((tag) => {
          if (tag && typeof tag === "string") {
            tags.add(tag.replace(/^#/, "").trim());
          }
        });
      } else if (typeof frontmatter.tags === "string") {
        frontmatter.tags.split(",").forEach((tag) => {
          const cleanTag = tag.trim().replace(/^#/, "");
          if (cleanTag) {
            tags.add(cleanTag);
          }
        });
      }
    }
    if (frontmatter.tag) {
      if (typeof frontmatter.tag === "string") {
        tags.add(frontmatter.tag.replace(/^#/, "").trim());
      }
    }
    if (frontmatter.categories) {
      if (Array.isArray(frontmatter.categories)) {
        frontmatter.categories.forEach((category) => {
          if (category && typeof category === "string") {
            tags.add(category.replace(/^#/, "").trim());
          }
        });
      }
    }
    console.log(`Extracted ${tags.size} tags from frontmatter:`, Array.from(tags));
    return Array.from(tags);
  }
  cleanContent(content) {
    return content.replace(/```[\s\S]*?```/g, "[CODE_BLOCK]").replace(/`[^`]+`/g, "[CODE]").replace(/!\[.*?\]\(.*?\)/g, "[IMAGE]").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").replace(/\n\s*\n\s*\n/g, "\n\n").trim();
  }
  async getFilesInFolder(folderPath, includeSubfolders) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder || !(folder instanceof import_obsidian.TFolder)) {
      return [];
    }
    const files = [];
    const collectFiles = (currentFolder) => {
      for (const child of currentFolder.children) {
        if (child instanceof import_obsidian.TFile && child.extension === "md") {
          files.push(child);
        } else if (child instanceof import_obsidian.TFolder && includeSubfolders) {
          collectFiles(child);
        }
      }
    };
    collectFiles(folder);
    return files;
  }
  async getFilesByTags(tags) {
    const allFiles = this.app.vault.getMarkdownFiles();
    const matchingFiles = [];
    for (const file of allFiles) {
      try {
        const fileCache = this.app.metadataCache.getFileCache(file);
        const fileTags = (0, import_obsidian.getAllTags)(fileCache) || [];
        const hasMatchingTag = tags.some(
          (tag) => fileTags.some(
            (fileTag) => fileTag.toLowerCase().includes(tag.toLowerCase())
          )
        );
        if (hasMatchingTag) {
          matchingFiles.push(file);
        }
      } catch (error) {
        console.warn(`Error checking tags for file ${file.path}:`, error);
      }
    }
    return matchingFiles;
  }
  async generateContentPreview(selection) {
    const maxPreviewLength = 500;
    const sampleFiles = selection.files.slice(0, 3);
    let preview = "";
    for (const filePath of sampleFiles) {
      const content = await this.processFile(filePath);
      if (content) {
        preview += `**${content.title}**: ${content.content.substring(0, 100)}...

`;
      }
      if (preview.length > maxPreviewLength) {
        break;
      }
    }
    return preview.trim();
  }
  getAllTags() {
    const allTags = /* @__PURE__ */ new Set();
    const files = this.app.vault.getMarkdownFiles();
    files.forEach((file) => {
      const fileCache = this.app.metadataCache.getFileCache(file);
      const tags = (0, import_obsidian.getAllTags)(fileCache);
      if (tags) {
        tags.forEach((tag) => allTags.add(tag.replace("#", "")));
      }
    });
    return Array.from(allTags).sort();
  }
};

// src/services/llmService.ts
var import_obsidian2 = require("obsidian");
var LLMService = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async testConnection() {
    try {
      console.log("Testing API connection with provider:", this.settings.llmProvider);
      console.log("Using model:", this.settings.model);
      console.log("API key present:", !!this.settings.apiKey);
      if (!this.settings.apiKey || this.settings.apiKey.trim() === "") {
        return {
          success: false,
          error: "No API key provided. Please enter your API key in settings."
        };
      }
      const testPrompt = "Please respond with exactly 'Connection successful' to confirm the API is working.";
      const response = await this.makeAPICall(testPrompt, [], 50);
      if (response.success && response.structure.includes("Connection successful")) {
        return { success: true };
      } else {
        return {
          success: false,
          error: response.error || "Test response was unexpected"
        };
      }
    } catch (error) {
      console.error("Connection test failed:", error);
      return {
        success: false,
        error: `Connection failed: ${error.message}`
      };
    }
  }
  async generateMindmapStructure(processedContent, allTags) {
    const context = {
      sourceFiles: processedContent.map((c) => c.filePath),
      existingTags: allTags,
      tagHierarchy: this.buildTagHierarchy(allTags)
    };
    const prompt = this.buildMindmapPrompt(processedContent, allTags, context);
    const maxTokens = Math.min(this.settings.maxTokens, 4e3);
    console.log("Generated LLM prompt:", prompt.substring(0, 500) + "...");
    console.log("Using STEEPLE framework:", prompt.includes("STEEPLE"));
    return await this.makeAPICall(prompt, allTags, maxTokens);
  }
  buildMindmapPrompt(processedContent, allTags, context) {
    const tagWeightingInstructions = this.getTagWeightingInstructions();
    const multiParentInstructions = this.settings.enableMultiParent ? "\n- Create cross-connections where content relates to multiple STEEPLE categories using [ALSO: Parent Category] notation" : "";
    const contentSummary = processedContent.map(
      (content) => `**${content.title}** (Tags: ${content.tags.join(", ")})
${content.content.substring(0, 300)}...`
    ).join("\n\n");
    return `Analyze the following content and organize it using the STEEPLE framework. Return ONLY the mindmap structure in the exact format shown below.

CONTENT:
${contentSummary}

USER TAGS: ${allTags.join(", ")}
${tagWeightingInstructions}

INSTRUCTIONS:
- Use ONLY the 7 STEEPLE categories as main headings
- Include only STEEPLE categories that have relevant content
- Create 2-3 subcategories under each main category
- Put specific topics under subcategories
- Use existing user tags where relevant${multiParentInstructions}
- For topics that span multiple STEEPLE areas, add [ALSO: CategoryName] to show cross-connections

REQUIRED OUTPUT FORMAT (copy this structure exactly):

# Social
- Demographics & Culture
  - Population trends
  - Cultural shifts
- Education & Health
  - Learning systems
  - Healthcare trends

# Technological  
- Innovation & AI
  - Emerging technologies
  - AI governance [ALSO: Ethical]
- Digital Transformation
  - Platform technologies  
  - Data systems

# Economic
- Market Dynamics
  - Business models
  - Financial systems
- Economic Policy
  - Trade regulations
  - Economic indicators

# Environmental
- Sustainability
  - Green technology
  - Resource management
- Climate Impact
  - Environmental policies
  - Conservation efforts

# Political
- Governance
  - Political systems  
  - Government policies
- Regulatory Framework
  - Policy development
  - Political stability

# Legal
- Compliance
  - Legal frameworks
  - Regulatory requirements
- Rights & Obligations
  - Legal standards
  - Enforcement

# Ethical
- Corporate Responsibility
  - Business ethics
  - Stakeholder obligations
- Privacy & Fairness
  - Data protection
  - Ethical standards

IMPORTANT: 
- Use # for main STEEPLE categories only
- Use - for subcategories (no spaces before dash)  
- Use  - for specific items (2 spaces before dash)
- Only include categories with actual content
- Organize all content into this STEEPLE structure`;
  }
  getTagWeightingInstructions() {
    switch (this.settings.tagWeighting) {
      case "high":
        return "\nThese tags should STRONGLY influence your mindmap structure. Use them as primary organizing principles.";
      case "medium":
        return "\nThese tags should guide your analysis but balance them with content-derived themes.";
      case "low":
        return "\nThese tags provide context but prioritize content-derived themes and concepts.";
      default:
        return "";
    }
  }
  buildTagHierarchy(tags) {
    const hierarchy = {};
    tags.forEach((tag) => {
      if (tag.includes("/")) {
        const parts = tag.split("/");
        const parent = parts[0];
        const child = parts[1];
        if (!hierarchy[parent]) {
          hierarchy[parent] = [];
        }
        hierarchy[parent].push(child);
      }
    });
    return hierarchy;
  }
  async makeAPICall(prompt, tags, maxTokens) {
    try {
      if (this.settings.llmProvider === "claude") {
        return await this.callClaudeAPI(prompt, maxTokens);
      } else if (this.settings.llmProvider === "openai") {
        return await this.callOpenAIAPI(prompt, maxTokens);
      } else {
        return await this.callCustomAPI(prompt, maxTokens);
      }
    } catch (error) {
      return {
        success: false,
        structure: "",
        error: error.message
      };
    }
  }
  async callClaudeAPI(prompt, maxTokens) {
    var _a, _b;
    try {
      console.log("Claude API call starting with model:", this.settings.model);
      const response = await (0, import_obsidian2.requestUrl)({
        url: "https://api.anthropic.com/v1/messages",
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": this.settings.apiKey,
          "anthropic-version": "2023-06-01"
        },
        body: JSON.stringify({
          model: this.settings.model,
          max_tokens: Math.max(maxTokens, 50),
          // Ensure minimum tokens
          messages: [
            {
              role: "user",
              content: prompt
            }
          ]
        })
      });
      console.log("Claude API response status:", response.status);
      if (response.status >= 400) {
        const errorData = ((_a = response.json) == null ? void 0 : _a.error) || { message: response.text || "Unknown error" };
        throw new Error(`Claude API error: ${response.status} - ${errorData.message}`);
      }
      const data = response.json;
      console.log("Claude API response received:", data);
      return {
        success: true,
        structure: data.content[0].text,
        tokensUsed: (_b = data.usage) == null ? void 0 : _b.output_tokens
      };
    } catch (error) {
      console.error("Claude API call failed:", error);
      throw error;
    }
  }
  async callOpenAIAPI(prompt, maxTokens) {
    var _a, _b;
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.apiKey}`
      },
      body: JSON.stringify({
        model: this.settings.model,
        max_tokens: maxTokens,
        messages: [
          {
            role: "user",
            content: prompt
          }
        ]
      })
    });
    if (response.status >= 400) {
      const errorData = ((_a = response.json) == null ? void 0 : _a.error) || { message: response.text || "Unknown error" };
      throw new Error(`OpenAI API error: ${response.status} - ${errorData.message}`);
    }
    const data = response.json;
    return {
      success: true,
      structure: data.choices[0].message.content,
      tokensUsed: (_b = data.usage) == null ? void 0 : _b.total_tokens
    };
  }
  async callCustomAPI(prompt, maxTokens) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!this.settings.customApiUrl) {
      throw new Error("Custom API URL not configured");
    }
    const response = await (0, import_obsidian2.requestUrl)({
      url: `${this.settings.customApiUrl}/chat/completions`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.apiKey}`
      },
      body: JSON.stringify({
        model: this.settings.model,
        max_tokens: maxTokens,
        messages: [
          {
            role: "user",
            content: prompt
          }
        ]
      })
    });
    if (response.status >= 400) {
      const errorData = ((_a = response.json) == null ? void 0 : _a.error) || { message: response.text || "Unknown error" };
      throw new Error(`Custom API error: ${response.status} - ${errorData.message}`);
    }
    const data = response.json;
    return {
      success: true,
      structure: ((_d = (_c = (_b = data.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content) || ((_f = (_e = data.content) == null ? void 0 : _e[0]) == null ? void 0 : _f.text) || "",
      tokensUsed: (_g = data.usage) == null ? void 0 : _g.total_tokens
    };
  }
};

// src/services/mindmapGenerator.ts
var MindmapGenerator = class {
  async buildStructure(llmResponse, processedContent, settings) {
    const nodes = this.parseLLMResponse(llmResponse);
    const enrichedNodes = this.enrichNodesWithContent(nodes, processedContent);
    const finalNodes = settings.enableMultiParent ? this.processMultiParentConnections(enrichedNodes) : enrichedNodes;
    return {
      nodes: finalNodes,
      rootNodes: finalNodes.filter((node) => node.parents.length === 0).map((node) => node.id),
      metadata: {
        generatedAt: new Date().toISOString(),
        sourceCount: processedContent.length,
        tagCount: this.countUniqueTags(processedContent),
        llmProvider: settings.llmProvider,
        model: settings.model
      }
    };
  }
  parseLLMResponse(response) {
    var _a, _b;
    console.log("Parsing LLM response:", response.substring(0, 500) + "...");
    const nodes = [];
    const lines = response.split("\n").map((line) => line.replace(/\r/g, ""));
    const nodeStack = [];
    let currentId = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();
      if (!trimmedLine || trimmedLine.startsWith("```") || trimmedLine.startsWith("CONTENT:") || trimmedLine.startsWith("USER TAGS:") || trimmedLine.startsWith("INSTRUCTIONS:") || trimmedLine.startsWith("REQUIRED OUTPUT:") || trimmedLine.startsWith("IMPORTANT:")) {
        continue;
      }
      console.log(`Processing line ${i + 1}: "${line}" (trimmed: "${trimmedLine}")`);
      const isHeader = trimmedLine.startsWith("#");
      const isDash = trimmedLine.startsWith("-") && !line.match(/^\s/);
      const isIndentedDash = line.match(/^\s+-/);
      let level = 0;
      if (isHeader) {
        level = 0;
      } else if (isDash) {
        level = 1;
      } else if (isIndentedDash) {
        const leadingSpaces = ((_b = (_a = line.match(/^(\s*)/)) == null ? void 0 : _a[1]) == null ? void 0 : _b.length) || 0;
        level = Math.floor(leadingSpaces / 2) + 1;
      }
      console.log(`Line type - Header: ${isHeader}, Dash: ${!!isDash}, IndentedDash: ${!!isIndentedDash}, Level: ${level}`);
      if (isHeader) {
        const label = trimmedLine.replace(/^#+\s*/, "").trim();
        console.log(`Creating header node: "${label}"`);
        const node = {
          id: `node_${currentId++}`,
          label,
          content: label,
          parents: [],
          children: [],
          tags: [],
          sourceNotes: [],
          level: 0
        };
        nodes.push(node);
        nodeStack.length = 0;
        nodeStack.push({ node, level: 0 });
      } else if (isDash || isIndentedDash) {
        const label = trimmedLine.replace(/^-\s*/, "").trim();
        console.log(`Creating dash node: "${label}" at level ${level}`);
        const { label: cleanLabel, alsoParents } = this.parseNodeLabel(label);
        const node = {
          id: `node_${currentId++}`,
          label: cleanLabel,
          content: cleanLabel,
          parents: [],
          children: [],
          tags: alsoParents,
          sourceNotes: [],
          level
        };
        while (nodeStack.length > 0 && nodeStack[nodeStack.length - 1].level >= level) {
          console.log(`Popping node from stack: ${nodeStack[nodeStack.length - 1].node.label} (level ${nodeStack[nodeStack.length - 1].level})`);
          nodeStack.pop();
        }
        if (nodeStack.length > 0) {
          const parent = nodeStack[nodeStack.length - 1].node;
          console.log(`Setting parent: ${parent.label} -> ${cleanLabel}`);
          node.parents.push(parent.id);
          parent.children.push(node.id);
        } else {
          console.warn(`No parent found for node: ${cleanLabel}`);
        }
        nodes.push(node);
        nodeStack.push({ node, level });
      }
    }
    console.log(`Created ${nodes.length} nodes:`);
    nodes.forEach((node) => {
      console.log(`- ${node.label} (level: ${node.level}, children: ${node.children.length}, parents: ${node.parents.length})`);
    });
    return nodes;
  }
  getIndentationLevel(line) {
    let level = 0;
    for (const char of line) {
      if (char === " ") {
        level += 0.25;
      } else if (char === "	") {
        level += 1;
      } else if (char === "-") {
        break;
      } else if (!char.match(/\s/)) {
        break;
      }
    }
    return Math.floor(level);
  }
  parseNodeLabel(text) {
    text = text.replace(/^\[|\]$/g, "");
    const alsoMatch = text.match(/(.+?)\s*\[ALSO:\s*([^\]]+)\]/);
    if (alsoMatch) {
      return {
        label: alsoMatch[1].trim(),
        alsoParents: [alsoMatch[2].trim()]
      };
    }
    return {
      label: text,
      alsoParents: []
    };
  }
  enrichNodesWithContent(nodes, processedContent) {
    const contentIndex = this.buildContentSearchIndex(processedContent);
    return nodes.map((node) => {
      const relevantContent = this.findRelevantContent(node.label, contentIndex, processedContent);
      return {
        ...node,
        content: relevantContent.summary || node.label,
        sourceNotes: relevantContent.sourceFiles,
        tags: [.../* @__PURE__ */ new Set([...node.tags, ...relevantContent.tags])]
        // Merge tags
      };
    });
  }
  buildContentSearchIndex(processedContent) {
    const index = /* @__PURE__ */ new Map();
    processedContent.forEach((content) => {
      const keywords = this.extractKeywords(content.title + " " + content.content);
      keywords.forEach((keyword) => {
        if (!index.has(keyword)) {
          index.set(keyword, []);
        }
        index.get(keyword).push(content);
      });
    });
    return index;
  }
  extractKeywords(text) {
    return text.toLowerCase().replace(/[^\w\s]/g, " ").split(/\s+/).filter((word) => word.length > 3).filter((word) => !this.isStopWord(word));
  }
  isStopWord(word) {
    const stopWords = /* @__PURE__ */ new Set([
      "the",
      "and",
      "or",
      "but",
      "in",
      "on",
      "at",
      "to",
      "for",
      "of",
      "with",
      "by",
      "this",
      "that",
      "these",
      "those",
      "a",
      "an",
      "is",
      "was",
      "are",
      "were",
      "be",
      "been",
      "being",
      "have",
      "has",
      "had",
      "do",
      "does",
      "did",
      "will",
      "would",
      "could",
      "should",
      "may",
      "might",
      "must",
      "can",
      "about",
      "into",
      "through",
      "during",
      "before",
      "after",
      "above",
      "below",
      "from",
      "up",
      "down",
      "out"
    ]);
    return stopWords.has(word.toLowerCase());
  }
  findRelevantContent(nodeLabel, contentIndex, allContent) {
    const keywords = this.extractKeywords(nodeLabel);
    const relevantContent = [];
    const sourceFiles = /* @__PURE__ */ new Set();
    const tags = /* @__PURE__ */ new Set();
    keywords.forEach((keyword) => {
      const matchingContent = contentIndex.get(keyword) || [];
      matchingContent.forEach((content) => {
        if (!relevantContent.some((c) => c.filePath === content.filePath)) {
          relevantContent.push(content);
        }
        sourceFiles.add(content.filePath);
        content.tags.forEach((tag) => tags.add(tag));
      });
    });
    const summary = this.generateContentSummary(relevantContent, nodeLabel);
    return {
      summary,
      sourceFiles: Array.from(sourceFiles),
      tags: Array.from(tags)
    };
  }
  generateContentSummary(relevantContent, nodeLabel) {
    if (relevantContent.length === 0) {
      return nodeLabel;
    }
    const keywords = this.extractKeywords(nodeLabel);
    const relevantSentences = [];
    relevantContent.forEach((content) => {
      const sentences = content.content.split(/[.!?]+/);
      sentences.forEach((sentence) => {
        const sentenceKeywords = this.extractKeywords(sentence);
        const keywordOverlap = keywords.filter((k) => sentenceKeywords.includes(k));
        if (keywordOverlap.length > 0) {
          relevantSentences.push(sentence.trim());
        }
      });
    });
    return relevantSentences.length > 0 ? relevantSentences[0].substring(0, 150) + "..." : nodeLabel;
  }
  processMultiParentConnections(nodes) {
    console.log("Processing multi-parent connections...");
    const nodeByLabel = new Map(nodes.map((node) => [node.label.toLowerCase(), node]));
    const steepleCategories = /* @__PURE__ */ new Map([
      ["social", "Social"],
      ["technological", "Technological"],
      ["economic", "Economic"],
      ["environmental", "Environmental"],
      ["political", "Political"],
      ["legal", "Legal"],
      ["ethical", "Ethical"]
    ]);
    return nodes.map((node) => {
      const additionalParents = [];
      node.tags.forEach((tag) => {
        console.log(`Processing tag "${tag}" for node "${node.label}"`);
        let parentNode = nodeByLabel.get(tag.toLowerCase());
        if (!parentNode) {
          const steepleKey = steepleCategories.get(tag.toLowerCase());
          if (steepleKey) {
            parentNode = nodeByLabel.get(steepleKey.toLowerCase());
          }
        }
        if (!parentNode) {
          for (const [key, fullName] of steepleCategories) {
            if (tag.toLowerCase().includes(key) || fullName.toLowerCase().includes(tag.toLowerCase())) {
              parentNode = nodeByLabel.get(fullName.toLowerCase());
              break;
            }
          }
        }
        if (parentNode && parentNode.id !== node.id && !node.parents.includes(parentNode.id)) {
          console.log(`Adding multi-parent connection: "${node.label}" -> "${parentNode.label}"`);
          additionalParents.push(parentNode.id);
          if (!parentNode.children.includes(node.id)) {
            parentNode.children.push(node.id);
          }
        }
      });
      const processedTags = node.tags.filter((tag) => {
        const isParentRef = nodeByLabel.has(tag.toLowerCase()) || steepleCategories.has(tag.toLowerCase()) || Array.from(steepleCategories.values()).some(
          (cat) => cat.toLowerCase().includes(tag.toLowerCase())
        );
        return !isParentRef;
      });
      return {
        ...node,
        parents: [...node.parents, ...additionalParents],
        tags: processedTags
      };
    });
  }
  countUniqueTags(processedContent) {
    const allTags = /* @__PURE__ */ new Set();
    processedContent.forEach((content) => {
      content.tags.forEach((tag) => allTags.add(tag));
    });
    return allTags.size;
  }
  convertToMarkdown(structure) {
    const header = this.generateMarkdownHeader(structure);
    const mindmapContent = this.generateMarkdownMindmap(structure);
    return `${header}

${mindmapContent}`;
  }
  generateMarkdownHeader(structure) {
    const date = new Date(structure.metadata.generatedAt).toLocaleString();
    return `---
title: "AI Generated Mindmap"
created: "${structure.metadata.generatedAt}"
tags: [ai-mindmap, auto-generated]
---

# AI Generated Mindmap

**Generated:** ${date}  
**Sources:** ${structure.metadata.sourceCount} files  
**Tags:** ${structure.metadata.tagCount} unique tags  
**Model:** ${structure.metadata.llmProvider} (${structure.metadata.model})

---

## Mindmap Structure

\`\`\`markmap
---
markmap:
  colorFreezeLevel: 2
---`;
  }
  generateMarkdownMindmap(structure) {
    const nodeMap = new Map(structure.nodes.map((node) => [node.id, node]));
    let markdown = "";
    structure.rootNodes.forEach((rootId) => {
      const rootNode = nodeMap.get(rootId);
      if (rootNode) {
        markdown += this.generateNodeMarkdown(rootNode, nodeMap, 0);
      }
    });
    markdown += "\n```\n\n## Source Files\n\n";
    const allSourceFiles = /* @__PURE__ */ new Set();
    structure.nodes.forEach((node) => {
      node.sourceNotes.forEach((source) => allSourceFiles.add(source));
    });
    Array.from(allSourceFiles).forEach((file) => {
      markdown += `- [[${file}]]
`;
    });
    return markdown;
  }
  generateNodeMarkdown(node, nodeMap, depth) {
    const indent = "  ".repeat(depth);
    let markdown = `${indent}- ${node.label}
`;
    node.children.forEach((childId) => {
      const childNode = nodeMap.get(childId);
      if (childNode) {
        markdown += this.generateNodeMarkdown(childNode, nodeMap, depth + 1);
      }
    });
    return markdown;
  }
};

// src/services/mindmapPersistence.ts
var MindmapPersistenceService = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
    this.library = {
      savedMindmaps: {},
      combineHistory: [],
      duplicateResolutionRules: [],
      version: "1.0.0"
    };
  }
  get settings() {
    return this.plugin.settings;
  }
  async initialize() {
    try {
      console.log("Initializing mindmap persistence service...");
      await this.loadLibrary();
      console.log("Mindmap persistence service initialized");
      console.log(`Loaded ${Object.keys(this.library.savedMindmaps).length} existing saved mindmaps`);
    } catch (error) {
      console.error("Failed to initialize persistence service:", error);
    }
  }
  async loadLibrary() {
    try {
      console.log("Loading mindmap library...");
      const libraryData = await this.plugin.loadData();
      if (libraryData && libraryData.mindmapLibrary) {
        this.library = libraryData.mindmapLibrary;
        console.log(`Successfully loaded library with ${Object.keys(this.library.savedMindmaps).length} mindmaps`);
      } else {
        console.log("No existing library found, starting with empty library");
      }
    } catch (error) {
      console.warn("Failed to load mindmap library, using empty library:", error);
    }
  }
  async saveLibrary() {
    try {
      console.log("Saving mindmap library...");
      const pluginData = await this.plugin.loadData() || {};
      pluginData.mindmapLibrary = this.library;
      await this.plugin.saveData(pluginData);
      console.log(`Successfully saved library with ${Object.keys(this.library.savedMindmaps).length} mindmaps`);
    } catch (error) {
      console.error("Failed to save mindmap library:", error);
      throw error;
    }
  }
  async saveMindmap(structure, sourceFiles, name, description) {
    var _a;
    console.log("Starting saveMindmap process...");
    console.log("Structure received:", structure ? "yes" : "no");
    console.log("Source files count:", sourceFiles.length);
    console.log("Name provided:", name || "auto-generated");
    const id = this.generateId();
    const timestamp = new Date().toISOString();
    const mindmapName = name || this.generateAutoName(sourceFiles, structure);
    console.log("Final mindmap name:", mindmapName);
    const safeFileName = this.sanitizeFileName(mindmapName);
    const fileName = `${safeFileName}.md`;
    const steepleCategories = this.extractSteepleCategories(structure);
    console.log("STEEPLE categories found:", steepleCategories);
    const savedMindmap = {
      id,
      name: mindmapName,
      description,
      createdAt: timestamp,
      modifiedAt: timestamp,
      sourceFiles: [...sourceFiles],
      sourceCount: sourceFiles.length,
      structure,
      metadata: {
        llmProvider: structure.metadata.llmProvider,
        model: structure.metadata.model,
        tokensUsed: structure.metadata.sourceCount,
        // Placeholder
        processingTime: 0,
        // Placeholder
        steepleCategories
      }
    };
    try {
      console.log(`Attempting to save mindmap with ID: ${id}`);
      await this.ensureMindmapsFolder();
      const markdownContent = this.generateMindmapMarkdown(savedMindmap);
      console.log("Generated markdown content length:", markdownContent.length);
      const folderPath = this.settings.mindmapsFolder;
      const filePath = `${folderPath}/${fileName}`;
      console.log("Saving to path:", filePath);
      await this.app.vault.create(filePath, markdownContent);
      console.log("Successfully created markdown file");
      if (this.settings.saveFormat === "both") {
        this.library.savedMindmaps[id] = savedMindmap;
        await this.saveLibrary();
        console.log("Also saved metadata to plugin data");
      }
      console.log(`Successfully saved mindmap "${mindmapName}" to ${filePath}`);
      return filePath;
    } catch (error) {
      console.error("Failed to save mindmap:", error);
      console.error("Error details:", error.message, error.stack);
      if ((_a = error.message) == null ? void 0 : _a.includes("already exists")) {
        const timestampedName = `${safeFileName}-${Date.now()}`;
        const newFileName = `${timestampedName}.md`;
        const newFilePath = `${this.settings.mindmapsFolder}/${newFileName}`;
        try {
          const markdownContent = this.generateMindmapMarkdown(savedMindmap);
          await this.app.vault.create(newFilePath, markdownContent);
          console.log(`Saved with timestamp: ${newFilePath}`);
          return newFilePath;
        } catch (retryError) {
          console.error("Failed even with timestamp:", retryError);
          throw retryError;
        }
      }
      throw error;
    }
  }
  async loadMindmap(id) {
    try {
      console.log(`Loading mindmap with ID: ${id}`);
      if (this.library.savedMindmaps[id]) {
        console.log(`Found mindmap in library: ${this.library.savedMindmaps[id].name}`);
        return this.library.savedMindmaps[id];
      }
      const allMindmaps = await this.getAllMindmaps();
      const mindmap = allMindmaps.find((m) => m.id === id);
      if (mindmap) {
        console.log(`Found mindmap in files: ${mindmap.name}`);
        return mindmap;
      }
      console.log(`Mindmap ${id} not found in library or files`);
      return null;
    } catch (error) {
      console.error(`Failed to load mindmap ${id}:`, error);
      return null;
    }
  }
  async deleteMindmap(id) {
    try {
      console.log(`Deleting mindmap ${id}`);
      delete this.library.savedMindmaps[id];
      await this.saveLibrary();
      console.log(`Successfully deleted mindmap ${id}`);
      return true;
    } catch (error) {
      console.error(`Failed to delete mindmap ${id}:`, error);
      return false;
    }
  }
  async renameMindmap(id, newName, newDescription) {
    try {
      console.log(`Renaming mindmap ${id} to: ${newName}`);
      const mindmap = this.library.savedMindmaps[id];
      if (!mindmap) {
        console.log(`Mindmap ${id} not found for renaming`);
        return false;
      }
      mindmap.name = newName;
      if (newDescription !== void 0) {
        mindmap.description = newDescription;
      }
      mindmap.modifiedAt = new Date().toISOString();
      await this.saveLibrary();
      console.log(`Successfully renamed mindmap ${id}`);
      return true;
    } catch (error) {
      console.error(`Failed to rename mindmap ${id}:`, error);
      return false;
    }
  }
  async getAllMindmaps() {
    try {
      console.log("Scanning mindmaps directory for actual files...");
      const folderPath = this.settings.mindmapsFolder;
      const folder = this.plugin.app.vault.getAbstractFileByPath(folderPath);
      if (!folder || !("children" in folder)) {
        console.log(`Mindmaps folder "${folderPath}" not found or empty`);
        return [];
      }
      const mindmapFiles = [];
      for (const file of folder.children) {
        if (file.name.endsWith(".md")) {
          try {
            const mindmap = await this.loadMindmapFromFile(file.path);
            if (mindmap) {
              mindmapFiles.push(mindmap);
            }
          } catch (error) {
            console.warn(`Failed to load mindmap from ${file.path}:`, error);
          }
        }
      }
      const sorted = mindmapFiles.sort(
        (a, b) => new Date(b.modifiedAt).getTime() - new Date(a.modifiedAt).getTime()
      );
      console.log(`Found ${sorted.length} mindmap files in directory`);
      return sorted;
    } catch (error) {
      console.error("Failed to scan mindmaps directory:", error);
      return Object.values(this.library.savedMindmaps).sort(
        (a, b) => new Date(b.modifiedAt).getTime() - new Date(a.modifiedAt).getTime()
      );
    }
  }
  async loadMindmapFromFile(filePath) {
    var _a, _b;
    try {
      const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
      if (!file)
        return null;
      const content = await this.plugin.app.vault.read(file);
      const { frontmatter, body } = this.parseFrontmatter(content);
      const mindmapId = frontmatter["mindmap-id"] || frontmatter.mindmap_id || this.generateDeterministicId(file.path);
      const name = frontmatter.title || file.name.replace(".md", "");
      const createdAt = frontmatter.created || frontmatter.created_at || ((_a = file.stat) == null ? void 0 : _a.ctime) ? new Date(file.stat.ctime).toISOString() : new Date().toISOString();
      const modifiedAt = frontmatter.modified || frontmatter.modified_at || ((_b = file.stat) == null ? void 0 : _b.mtime) ? new Date(file.stat.mtime).toISOString() : new Date().toISOString();
      const structure = this.parseMarkdownToStructure(body);
      const savedMindmap = {
        id: mindmapId,
        name,
        description: frontmatter.description,
        createdAt,
        modifiedAt,
        sourceFiles: frontmatter["source-files"] || frontmatter.source_files || [],
        sourceCount: frontmatter["source-count"] || frontmatter.source_count || 0,
        structure,
        metadata: {
          llmProvider: frontmatter["llm-provider"] || frontmatter.llm_provider || "unknown",
          model: frontmatter["llm-model"] || frontmatter.model || "unknown",
          tokensUsed: frontmatter["tokens-used"] || frontmatter.tokens_used,
          processingTime: frontmatter["processing-time"] || frontmatter.processing_time,
          steepleCategories: frontmatter["steeple-categories"] || frontmatter.steeple_categories || []
        }
      };
      return savedMindmap;
    } catch (error) {
      console.error(`Failed to load mindmap from file ${filePath}:`, error);
      return null;
    }
  }
  parseFrontmatter(content) {
    const frontmatterRegex = /^---\s*\r?\n(.*?)\r?\n---\s*\r?\n(.*)/s;
    const match = content.match(frontmatterRegex);
    if (match) {
      try {
        const frontmatterText = match[1];
        const frontmatter = {};
        const lines = frontmatterText.split(/\r?\n/);
        for (const line of lines) {
          const colonIndex = line.indexOf(":");
          if (colonIndex > 0) {
            const key = line.substring(0, colonIndex).trim();
            const valueText = line.substring(colonIndex + 1).trim();
            let value;
            if (valueText.startsWith("[") && valueText.endsWith("]")) {
              const arrayContent = valueText.slice(1, -1);
              value = arrayContent.split(",").map((item) => item.trim().replace(/['"]/g, "")).filter((item) => item);
            } else if (valueText === "true" || valueText === "false") {
              value = valueText === "true";
            } else if (!isNaN(Number(valueText)) && valueText.trim() !== "") {
              value = Number(valueText);
            } else {
              value = valueText.replace(/['"]/g, "");
            }
            frontmatter[key] = value;
          }
        }
        return { frontmatter, body: match[2] };
      } catch (error) {
        console.warn("Error parsing frontmatter:", error);
        return { frontmatter: {}, body: content };
      }
    }
    return { frontmatter: {}, body: content };
  }
  parseMarkdownToStructure(markdown) {
    try {
      const nodes = [];
      const lines = markdown.split("\n");
      const nodeMap = /* @__PURE__ */ new Map();
      const rootNodes = [];
      for (const line of lines) {
        const trimmedLine = line.trim();
        if (!trimmedLine || trimmedLine.startsWith("```"))
          continue;
        const headerMatch = trimmedLine.match(/^(#{1,6})\s+(.+)$/);
        const listMatch = trimmedLine.match(/^(\s*)-\s+(.+)$/);
        if (headerMatch) {
          const level = headerMatch[1].length - 1;
          const label = headerMatch[2].replace(/^\*\*|\*\*$/g, "");
          const nodeId = this.generateId();
          const node = {
            id: nodeId,
            label,
            content: "",
            parents: [],
            children: [],
            tags: [],
            sourceNotes: [],
            level
          };
          nodes.push(node);
          nodeMap.set(nodeId, node);
          if (level === 0) {
            rootNodes.push(nodeId);
          }
        } else if (listMatch) {
          const indent = listMatch[1].length;
          const level = Math.floor(indent / 2) + 1;
          const label = listMatch[2].replace(/^\*\*|\*\*$/g, "");
          const nodeId = this.generateId();
          const node = {
            id: nodeId,
            label,
            content: "",
            parents: [],
            children: [],
            tags: [],
            sourceNotes: [],
            level
          };
          nodes.push(node);
          nodeMap.set(nodeId, node);
        }
      }
      for (let i = 0; i < nodes.length; i++) {
        const currentNode = nodes[i];
        for (let j = i - 1; j >= 0; j--) {
          const potentialParent = nodes[j];
          if (potentialParent.level < currentNode.level) {
            currentNode.parents.push(potentialParent.id);
            potentialParent.children.push(currentNode.id);
            break;
          }
        }
      }
      return {
        nodes,
        rootNodes,
        metadata: {
          generatedAt: new Date().toISOString(),
          sourceCount: 0,
          tagCount: 0,
          llmProvider: "file-parser",
          model: "markdown-parser"
        }
      };
    } catch (error) {
      console.error("Failed to parse markdown to structure:", error);
      return {
        nodes: [],
        rootNodes: [],
        metadata: {
          generatedAt: new Date().toISOString(),
          sourceCount: 0,
          tagCount: 0,
          llmProvider: "file-parser",
          model: "markdown-parser"
        }
      };
    }
  }
  async searchMindmaps(query) {
    const lowerQuery = query.toLowerCase();
    const allMindmaps = await this.getAllMindmaps();
    return allMindmaps.filter(
      (mindmap) => {
        var _a;
        return mindmap.name.toLowerCase().includes(lowerQuery) || ((_a = mindmap.description) == null ? void 0 : _a.toLowerCase().includes(lowerQuery)) || mindmap.sourceFiles.some((file) => file.toLowerCase().includes(lowerQuery));
      }
    );
  }
  // Basic combining functionality - combines two or more mindmaps
  async combineMindmaps(mindmapIds, combinedName, options) {
    try {
      console.log(`Combining ${mindmapIds.length} mindmaps: ${mindmapIds.join(", ")}`);
      const mindmaps = [];
      for (const id of mindmapIds) {
        console.log(`Trying to load mindmap with ID: ${id}`);
        const mindmap = await this.loadMindmap(id);
        if (mindmap) {
          console.log(`Successfully loaded mindmap: ${mindmap.name}`);
          mindmaps.push(mindmap);
        } else {
          console.warn(`Failed to load mindmap with ID: ${id}`);
        }
      }
      console.log(`Successfully loaded ${mindmaps.length} out of ${mindmapIds.length} requested mindmaps`);
      if (mindmaps.length < 2) {
        throw new Error("Need at least 2 mindmaps to combine");
      }
      const combinedStructure = await this.performStructureMerge(mindmaps, options);
      const allSourceFiles = mindmaps.reduce((acc, mindmap) => {
        return [...acc, ...mindmap.sourceFiles];
      }, []);
      const uniqueSourceFiles = [...new Set(allSourceFiles)];
      const combinedId = await this.saveMindmap(
        combinedStructure,
        uniqueSourceFiles,
        combinedName,
        `Combined from: ${mindmaps.map((m) => m.name).join(", ")}`
      );
      console.log(`Successfully combined mindmaps into ${combinedId}`);
      return combinedId;
    } catch (error) {
      console.error("Failed to combine mindmaps:", error);
      throw error;
    }
  }
  async performStructureMerge(mindmaps, options) {
    console.log("Performing structure merge...");
    const baseMindmap = mindmaps[0];
    let combinedNodes = [...baseMindmap.structure.nodes];
    let nodeIdCounter = Math.max(...combinedNodes.map((n) => parseInt(n.id.split("_")[1]) || 0)) + 1;
    for (let i = 1; i < mindmaps.length; i++) {
      const currentMindmap = mindmaps[i];
      for (const newNode of currentMindmap.structure.nodes) {
        const existingNode = combinedNodes.find(
          (existing) => this.areNodesSimilar(existing, newNode, options)
        );
        if (existingNode && (options.conflictResolutionStrategy === "exact_match" /* EXACT_MATCH */ || options.conflictResolutionStrategy === "semantic_similarity" /* SEMANTIC_SIMILARITY */)) {
          this.mergeNodeData(existingNode, newNode, options);
        } else {
          const adjustedNode = {
            ...newNode,
            id: `node_${nodeIdCounter++}`,
            parents: [],
            // Will be rebuilt
            children: []
            // Will be rebuilt
          };
          combinedNodes.push(adjustedNode);
        }
      }
    }
    combinedNodes = this.rebuildSteepleHierarchy(combinedNodes);
    const combinedStructure = {
      nodes: combinedNodes,
      rootNodes: combinedNodes.filter((node) => node.level === 0).map((node) => node.id),
      metadata: {
        generatedAt: new Date().toISOString(),
        sourceCount: mindmaps.reduce((sum, m) => sum + m.sourceCount, 0),
        tagCount: new Set(combinedNodes.flatMap((n) => n.tags)).size,
        llmProvider: "combined",
        model: "multiple"
      }
    };
    return combinedStructure;
  }
  areNodesSimilar(node1, node2, options) {
    if (options.conflictResolutionStrategy === "exact_match" /* EXACT_MATCH */) {
      return node1.label.toLowerCase().trim() === node2.label.toLowerCase().trim();
    } else if (options.conflictResolutionStrategy === "semantic_similarity" /* SEMANTIC_SIMILARITY */) {
      const similarity = this.calculateSemanticSimilarity(node1.label, node2.label);
      return similarity >= options.maxSimilarityThreshold;
    }
    return false;
  }
  calculateSemanticSimilarity(text1, text2) {
    const normalize = (text) => text.toLowerCase().trim().replace(/[^\w\s]/g, "");
    const norm1 = normalize(text1);
    const norm2 = normalize(text2);
    if (norm1 === norm2)
      return 1;
    const words1 = new Set(norm1.split(/\s+/).filter((w) => w.length > 2));
    const words2 = new Set(norm2.split(/\s+/).filter((w) => w.length > 2));
    const intersection = new Set([...words1].filter((w) => words2.has(w)));
    const union = /* @__PURE__ */ new Set([...words1, ...words2]);
    if (union.size === 0)
      return 0;
    const jaccardSim = intersection.size / union.size;
    const stringSim = this.calculateStringSimilarity(norm1, norm2);
    return jaccardSim * 0.7 + stringSim * 0.3;
  }
  calculateStringSimilarity(str1, str2) {
    const maxLen = Math.max(str1.length, str2.length);
    if (maxLen === 0)
      return 1;
    const distance = this.levenshteinDistance(str1, str2);
    return (maxLen - distance) / maxLen;
  }
  levenshteinDistance(str1, str2) {
    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
    for (let i = 0; i <= str1.length; i++)
      matrix[0][i] = i;
    for (let j = 0; j <= str2.length; j++)
      matrix[j][0] = j;
    for (let j = 1; j <= str2.length; j++) {
      for (let i = 1; i <= str1.length; i++) {
        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[j][i] = Math.min(
          matrix[j][i - 1] + 1,
          // deletion
          matrix[j - 1][i] + 1,
          // insertion
          matrix[j - 1][i - 1] + indicator
          // substitution
        );
      }
    }
    return matrix[str2.length][str1.length];
  }
  mergeNodeData(existingNode, newNode, options) {
    existingNode.tags = [.../* @__PURE__ */ new Set([...existingNode.tags, ...newNode.tags])];
    if (options.deduplicateSourceLinks) {
      existingNode.sourceNotes = [.../* @__PURE__ */ new Set([...existingNode.sourceNotes, ...newNode.sourceNotes])];
    } else {
      existingNode.sourceNotes = [...existingNode.sourceNotes, ...newNode.sourceNotes];
    }
    if (existingNode.content.length < newNode.content.length) {
      existingNode.content = newNode.content;
    } else if (newNode.content.length > 0 && !existingNode.content.includes(newNode.content)) {
      existingNode.content += ` ${newNode.content}`;
    }
    console.log(`Merged node "${existingNode.label}": ${existingNode.sourceNotes.length} sources (dedup: ${options.deduplicateSourceLinks})`);
  }
  rebuildSteepleHierarchy(nodes) {
    console.log("Preserving STEEPLE hierarchy for combined mindmap...");
    const steepleCategories = ["Social", "Technological", "Economic", "Environmental", "Political", "Legal", "Ethical"];
    console.log(`Input: ${nodes.length} nodes with levels: ${nodes.map((n) => n.level).filter((v, i, a) => a.indexOf(v) === i).sort()}`);
    nodes.forEach((node) => {
      node.parents = [];
      node.children = [];
    });
    const rootNodes = nodes.filter((n) => steepleCategories.includes(n.label) && n.level === 0);
    const contentNodes = nodes.filter((n) => !steepleCategories.includes(n.label) || n.level > 0);
    console.log(`Found ${rootNodes.length} STEEPLE roots and ${contentNodes.length} content nodes`);
    steepleCategories.forEach((category) => {
      if (!rootNodes.find((n) => n.label === category)) {
        const newRoot = {
          id: `steeple_${category.toLowerCase()}`,
          label: category,
          content: `${category} aspects of the analysis`,
          parents: [],
          children: [],
          tags: [category.toLowerCase()],
          sourceNotes: [],
          level: 0
        };
        nodes.push(newRoot);
        rootNodes.push(newRoot);
        console.log(`Created missing STEEPLE root: ${category}`);
      }
    });
    const nodesByCategory = /* @__PURE__ */ new Map();
    steepleCategories.forEach((cat) => nodesByCategory.set(cat, []));
    contentNodes.forEach((node) => {
      var _a;
      const category = this.inferOriginalSteepleCategory(node, nodes) || this.inferSteepleCategory(node, nodes) || "Social";
      (_a = nodesByCategory.get(category)) == null ? void 0 : _a.push(node);
    });
    steepleCategories.forEach((category) => {
      const categoryNodes = nodesByCategory.get(category) || [];
      const rootNode = rootNodes.find((n) => n.label === category);
      if (categoryNodes.length === 0 || !rootNode)
        return;
      console.log(`Connecting ${categoryNodes.length} nodes under ${category}`);
      categoryNodes.sort((a, b) => a.level - b.level);
      this.connectNodesByLevel(categoryNodes, rootNode);
    });
    console.log(`Final result: ${nodes.length} total nodes properly organized under STEEPLE structure`);
    return nodes;
  }
  inferOriginalSteepleCategory(node, allNodes) {
    const alsoMatch = node.label.match(/\[ALSO:\s*(\w+)/i);
    if (alsoMatch) {
      const category = alsoMatch[1];
      const steepleMatch = ["Social", "Technological", "Economic", "Environmental", "Political", "Legal", "Ethical"].find((s) => s.toLowerCase().startsWith(category.toLowerCase()));
      if (steepleMatch)
        return steepleMatch;
    }
    return null;
  }
  connectNodesByLevel(nodes, rootNode) {
    const nodesByLevel = /* @__PURE__ */ new Map();
    nodes.forEach((node) => {
      var _a;
      if (!nodesByLevel.has(node.level)) {
        nodesByLevel.set(node.level, []);
      }
      (_a = nodesByLevel.get(node.level)) == null ? void 0 : _a.push(node);
    });
    const levels = Array.from(nodesByLevel.keys()).sort((a, b) => a - b);
    const level1Nodes = nodesByLevel.get(1) || [];
    level1Nodes.forEach((node) => {
      if (!node.parents.includes(rootNode.id)) {
        node.parents.push(rootNode.id);
        rootNode.children.push(node.id);
      }
    });
    for (let i = 1; i < levels.length - 1; i++) {
      const currentLevel = levels[i];
      const nextLevel = levels[i + 1];
      const currentLevelNodes = nodesByLevel.get(currentLevel) || [];
      const nextLevelNodes = nodesByLevel.get(nextLevel) || [];
      nextLevelNodes.forEach((child) => {
        let bestParent = currentLevelNodes[0];
        let bestScore = 0;
        currentLevelNodes.forEach((parent) => {
          const score = this.calculateNodeSimilarity(child, parent);
          if (score > bestScore) {
            bestScore = score;
            bestParent = parent;
          }
        });
        if (bestParent && !child.parents.includes(bestParent.id)) {
          child.parents.push(bestParent.id);
          bestParent.children.push(child.id);
        }
      });
    }
  }
  inferSteepleCategory(node, allNodes) {
    var _a;
    const steepleCategories = ["Social", "Technological", "Economic", "Environmental", "Political", "Legal", "Ethical"];
    const text = `${node.label} ${node.content} ${((_a = node.tags) == null ? void 0 : _a.join(" ")) || ""}`.toLowerCase();
    const steepleKeywords = {
      "Social": ["social", "culture", "community", "people", "society", "demographic", "lifestyle", "behavior"],
      "Technological": ["technology", "tech", "digital", "innovation", "automation", "ai", "software", "hardware", "system"],
      "Economic": ["economic", "financial", "cost", "price", "market", "business", "revenue", "profit", "investment"],
      "Environmental": ["environment", "climate", "green", "sustainable", "ecology", "carbon", "renewable", "natural"],
      "Political": ["political", "government", "policy", "regulation", "law", "compliance", "governance", "public"],
      "Legal": ["legal", "law", "court", "judge", "attorney", "contract", "liability", "rights", "legislation"],
      "Ethical": ["ethical", "moral", "responsibility", "privacy", "fairness", "transparency", "bias", "accountability"]
    };
    let bestCategory = null;
    let bestScore = 0;
    Object.entries(steepleKeywords).forEach(([category, keywords]) => {
      const score = keywords.reduce((acc, keyword) => {
        return acc + (text.includes(keyword) ? 1 : 0);
      }, 0);
      if (score > bestScore) {
        bestScore = score;
        bestCategory = category;
      }
    });
    return bestCategory;
  }
  connectNodesWithinCategory(categoryNodes, rootNode) {
    const nodesByLevel = /* @__PURE__ */ new Map();
    categoryNodes.forEach((node) => {
      var _a;
      if (!nodesByLevel.has(node.level)) {
        nodesByLevel.set(node.level, []);
      }
      (_a = nodesByLevel.get(node.level)) == null ? void 0 : _a.push(node);
    });
    const levels = Array.from(nodesByLevel.keys()).sort((a, b) => a - b);
    for (let i = 0; i < levels.length - 1; i++) {
      const currentLevel = levels[i];
      const nextLevel = levels[i + 1];
      const currentNodes = nodesByLevel.get(currentLevel) || [];
      const nextNodes = nodesByLevel.get(nextLevel) || [];
      nextNodes.forEach((child) => {
        let bestParent = currentNodes[0];
        let bestScore = 0;
        currentNodes.forEach((parent) => {
          const score = this.calculateNodeSimilarity(child, parent);
          if (score > bestScore) {
            bestScore = score;
            bestParent = parent;
          }
        });
        if (bestParent && !child.parents.includes(bestParent.id)) {
          child.parents.push(bestParent.id);
          bestParent.children.push(child.id);
        }
      });
    }
  }
  findBestParent(childNode, potentialParents) {
    let bestParent = null;
    let bestScore = 0;
    for (const parent of potentialParents) {
      const score = this.calculateNodeSimilarity(childNode, parent);
      if (score > bestScore) {
        bestScore = score;
        bestParent = parent;
      }
    }
    return bestScore > 0.3 ? bestParent : potentialParents[0];
  }
  calculateNodeSimilarity(node1, node2) {
    const words1 = node1.label.toLowerCase().split(/\s+/);
    const words2 = node2.label.toLowerCase().split(/\s+/);
    const intersection = words1.filter((word) => words2.includes(word));
    const union = [.../* @__PURE__ */ new Set([...words1, ...words2])];
    return intersection.length / union.length;
  }
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }
  generateDeterministicId(filePath) {
    let hash = 0;
    for (let i = 0; i < filePath.length; i++) {
      const char = filePath.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return "file_" + Math.abs(hash).toString(36);
  }
  generateAutoName(sourceFiles, structure) {
    const timestamp = new Date().toLocaleDateString();
    const fileCount = sourceFiles.length;
    const commonFolders = this.findCommonFolder(sourceFiles);
    const folderName = commonFolders ? commonFolders.split("/").pop() : "Mixed";
    return `${folderName} Analysis (${fileCount} files) - ${timestamp}`;
  }
  findCommonFolder(files) {
    if (files.length === 0)
      return null;
    const folders = files.map((file) => {
      const lastSlash = file.lastIndexOf("/");
      return lastSlash > 0 ? file.substring(0, lastSlash) : "";
    });
    const folderCounts = folders.reduce((acc, folder) => {
      acc[folder] = (acc[folder] || 0) + 1;
      return acc;
    }, {});
    const mostCommon = Object.entries(folderCounts).sort((a, b) => b[1] - a[1])[0];
    return mostCommon && mostCommon[1] > 1 ? mostCommon[0] : null;
  }
  extractSteepleCategories(structure) {
    const steepleKeywords = [
      "social",
      "technological",
      "economic",
      "environmental",
      "political",
      "legal",
      "ethical"
    ];
    const foundCategories = /* @__PURE__ */ new Set();
    structure.nodes.forEach((node) => {
      const labelLower = node.label.toLowerCase();
      steepleKeywords.forEach((keyword) => {
        if (labelLower.includes(keyword)) {
          foundCategories.add(keyword.charAt(0).toUpperCase() + keyword.slice(1));
        }
      });
    });
    return Array.from(foundCategories).sort();
  }
  async ensureMindmapsFolder() {
    const folderPath = this.settings.mindmapsFolder;
    console.log("Ensuring mindmaps folder exists:", folderPath);
    try {
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!folder) {
        console.log("Creating mindmaps folder:", folderPath);
        await this.app.vault.createFolder(folderPath);
        console.log("Successfully created folder");
      } else {
        console.log("Folder already exists");
      }
    } catch (error) {
      console.error("Error ensuring folder exists:", error);
    }
  }
  sanitizeFileName(name) {
    return name.replace(/[<>:"/\\|?*]/g, "-").replace(/\s+/g, " ").trim().slice(0, 200);
  }
  generateMindmapMarkdown(savedMindmap) {
    const mindmap = savedMindmap;
    const date = new Date(mindmap.createdAt).toLocaleString();
    const mindmapContent = this.convertStructureToMindmapNextGen(mindmap.structure);
    const frontmatter = `---
title: "${mindmap.name}"
created: "${mindmap.createdAt}"
modified: "${mindmap.modifiedAt}"
tags: [ai-mindmap, auto-generated, ${mindmap.metadata.steepleCategories.map((c) => c.toLowerCase()).join(", ")}]
mindmap-id: "${mindmap.id}"
source-count: ${mindmap.sourceCount}
llm-provider: "${mindmap.metadata.llmProvider}"
llm-model: "${mindmap.metadata.model}"
markmap:
  colorFreezeLevel: 2
  maxWidth: 150
  initialExpandLevel: 3
---

${mindmapContent}

# Source Files

${mindmap.sourceFiles.map((file) => `## [[${file}]]`).join("\n")}

---

*Generated: ${date} | Sources: ${mindmap.sourceCount} files | Model: ${mindmap.metadata.llmProvider} (${mindmap.metadata.model}) | STEEPLE Categories: ${mindmap.metadata.steepleCategories.join(", ")}*
`;
    return frontmatter;
  }
  convertStructureToMarkmap(structure) {
    const nodeMap = new Map(structure.nodes.map((node) => [node.id, node]));
    let markdown = "";
    structure.rootNodes.forEach((rootId) => {
      const rootNode = nodeMap.get(rootId);
      if (rootNode) {
        markdown += this.generateNodeMarkdown(rootNode, nodeMap, 0);
      }
    });
    return markdown || "# No Content Generated";
  }
  generateNodeMarkdown(node, nodeMap, depth) {
    const prefix = depth === 0 ? "# " : "  ".repeat(depth - 1) + "- ";
    let markdown = `${prefix}${node.label}`;
    if (node.sourceNotes && node.sourceNotes.length > 0) {
      const sourceLinks = node.sourceNotes.slice(0, 3).map((source) => {
        var _a;
        const fileName = ((_a = source.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || source;
        return `[[${source}|${fileName}]]`;
      }).join(", ");
      markdown += ` <small>(Sources: ${sourceLinks})</small>`;
    }
    markdown += "\n";
    node.children.forEach((childId) => {
      const childNode = nodeMap.get(childId);
      if (childNode) {
        markdown += this.generateNodeMarkdown(childNode, nodeMap, depth + 1);
      }
    });
    return markdown;
  }
  convertStructureToMindmapNextGen(structure) {
    const nodeMap = new Map(structure.nodes.map((node) => [node.id, node]));
    let markdown = "";
    structure.rootNodes.forEach((rootId) => {
      const rootNode = nodeMap.get(rootId);
      if (rootNode) {
        markdown += this.generateNextGenNode(rootNode, nodeMap, 1);
      }
    });
    return markdown || "# No Content Generated";
  }
  generateNextGenNode(node, nodeMap, headingLevel) {
    const headingPrefix = "#".repeat(Math.min(headingLevel, 6));
    let markdown = `${headingPrefix} ${node.label}`;
    if (node.sourceNotes && node.sourceNotes.length > 0) {
      markdown += "\n";
      node.sourceNotes.slice(0, 3).forEach((source) => {
        var _a;
        const fileName = ((_a = source.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || source;
        markdown += `- [[${source}|${fileName}]]
`;
      });
    }
    markdown += "\n";
    node.children.forEach((childId) => {
      const childNode = nodeMap.get(childId);
      if (childNode) {
        markdown += this.generateNextGenNode(childNode, nodeMap, headingLevel + 1);
      }
    });
    return markdown;
  }
  convertStructureToOutline(structure) {
    const nodeMap = new Map(structure.nodes.map((node) => [node.id, node]));
    let outline = "";
    structure.rootNodes.forEach((rootId) => {
      const rootNode = nodeMap.get(rootId);
      if (rootNode) {
        outline += this.generateOutlineNode(rootNode, nodeMap, 0);
      }
    });
    return outline || "*No content generated*";
  }
  generateOutlineNode(node, nodeMap, depth) {
    let outline = "";
    if (depth === 0) {
      outline = `## ${node.label}

`;
    } else {
      const indent = "  ".repeat(depth - 1);
      outline = `${indent}- **${node.label}**`;
      if (node.sourceNotes && node.sourceNotes.length > 0) {
        const sourceLinks = node.sourceNotes.slice(0, 2).map((source) => {
          var _a;
          const fileName = ((_a = source.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || source;
          return `[[${source}|${fileName}]]`;
        }).join(", ");
        outline += ` _(${sourceLinks})_`;
      }
      outline += "\n";
    }
    node.children.forEach((childId) => {
      const childNode = nodeMap.get(childId);
      if (childNode) {
        outline += this.generateOutlineNode(childNode, nodeMap, depth + 1);
      }
    });
    if (depth === 0) {
      outline += "\n";
    }
    return outline;
  }
};

// src/components/sourceSelectorModal.ts
var import_obsidian3 = require("obsidian");
var SourceSelectorModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, onSubmit) {
    super(app);
    this.plugin = plugin;
    this.onSubmit = onSubmit;
    this.selection = {
      files: [],
      folders: [],
      tags: [],
      includeSubfolders: false,
      contentPreview: ""
    };
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.selection = {
      files: [],
      folders: [],
      tags: [],
      includeSubfolders: false,
      contentPreview: ""
    };
    contentEl.createEl("h2", { text: "Select Content for AI Mindmap" });
    this.createFileSelection();
    this.createFolderSelection();
    this.createTagSelection();
    this.createOptionsSection();
    this.createPreviewSection();
    this.createActionButtons();
  }
  createFileSelection() {
    const { contentEl } = this;
    const fileSection = contentEl.createDiv();
    fileSection.createEl("h3", { text: "Individual Files" });
    const searchContainer = fileSection.createDiv({ cls: "file-search-container" });
    searchContainer.style.marginBottom = "10px";
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search files by name or path..."
    });
    searchInput.style.width = "100%";
    searchInput.style.padding = "8px";
    searchInput.style.marginBottom = "5px";
    searchInput.style.border = "1px solid var(--background-modifier-border)";
    searchInput.style.borderRadius = "4px";
    const folderSelect = searchContainer.createEl("select");
    folderSelect.style.width = "100%";
    folderSelect.style.padding = "6px";
    folderSelect.style.border = "1px solid var(--background-modifier-border)";
    folderSelect.style.borderRadius = "4px";
    folderSelect.style.marginBottom = "8px";
    folderSelect.createEl("option", { text: "All folders", value: "" });
    const allFolders = this.getAllUniqueFolders();
    allFolders.forEach((folder) => {
      folderSelect.createEl("option", { text: folder, value: folder });
    });
    const sortContainer = searchContainer.createDiv();
    sortContainer.style.display = "flex";
    sortContainer.style.gap = "10px";
    sortContainer.style.marginBottom = "8px";
    const sortSelect = sortContainer.createEl("select");
    sortSelect.style.padding = "4px";
    sortSelect.style.border = "1px solid var(--background-modifier-border)";
    sortSelect.style.borderRadius = "4px";
    sortSelect.createEl("option", { text: "Sort by Name", value: "name" });
    sortSelect.createEl("option", { text: "Sort by Path", value: "path" });
    sortSelect.createEl("option", { text: "Sort by Modified", value: "modified" });
    const toggleContainer = sortContainer.createDiv();
    const showSelectedOnly = toggleContainer.createEl("input", { type: "checkbox" });
    showSelectedOnly.id = "show-selected-only";
    const showSelectedLabel = toggleContainer.createEl("label", {
      text: "Show selected only",
      attr: { for: "show-selected-only" }
    });
    showSelectedLabel.style.marginLeft = "5px";
    showSelectedLabel.style.fontSize = "0.9em";
    const fileList = fileSection.createDiv({ cls: "file-selection-list" });
    const allMarkdownFiles = this.app.vault.getMarkdownFiles();
    let filteredFiles = [...allMarkdownFiles];
    const updateFileList = () => {
      fileList.empty();
      const searchTerm = searchInput.value.toLowerCase();
      const selectedFolder = folderSelect.value;
      const sortBy = sortSelect.value;
      const selectedOnly = showSelectedOnly.checked;
      filteredFiles = allMarkdownFiles.filter((file) => {
        const matchesSearch = searchTerm === "" || file.name.toLowerCase().includes(searchTerm) || file.path.toLowerCase().includes(searchTerm);
        const matchesFolder = selectedFolder === "" || file.path.startsWith(selectedFolder + "/") || file.path === selectedFolder;
        const matchesSelected = !selectedOnly || this.selection.files.includes(file.path);
        return matchesSearch && matchesFolder && matchesSelected;
      });
      filteredFiles.sort((a, b) => {
        var _a, _b;
        switch (sortBy) {
          case "name":
            return a.name.localeCompare(b.name);
          case "path":
            return a.path.localeCompare(b.path);
          case "modified":
            return (((_a = b.stat) == null ? void 0 : _a.mtime) || 0) - (((_b = a.stat) == null ? void 0 : _b.mtime) || 0);
          default:
            return 0;
        }
      });
      const displayLimit = searchTerm || selectedFolder || selectedOnly ? 200 : 50;
      const filesToShow = filteredFiles.slice(0, displayLimit);
      filesToShow.forEach((file) => {
        var _a;
        const fileItem = fileList.createDiv({ cls: "file-item" });
        const checkbox = fileItem.createEl("input", { type: "checkbox" });
        checkbox.id = `file-${file.path}`;
        checkbox.checked = this.selection.files.includes(file.path);
        checkbox.addEventListener("change", (e) => {
          const target = e.target;
          if (!this.selection) {
            console.error("Selection object is undefined!");
            return;
          }
          if (target.checked) {
            if (!this.selection.files.includes(file.path)) {
              this.selection.files.push(file.path);
            }
          } else {
            this.selection.files = this.selection.files.filter((f) => f !== file.path);
          }
          this.updatePreview();
          if (showSelectedOnly.checked) {
            updateFileList();
          }
        });
        const label = fileItem.createEl("label", {
          text: file.name,
          attr: { for: `file-${file.path}` }
        });
        label.addClass("file-label");
        const pathDiv = fileItem.createEl("div", {
          text: file.path,
          cls: "file-path"
        });
        if ((_a = file.stat) == null ? void 0 : _a.mtime) {
          const modifiedDate = new Date(file.stat.mtime).toLocaleDateString();
          pathDiv.textContent += ` \u2022 Modified: ${modifiedDate}`;
        }
      });
      const countDiv = fileList.createDiv({ cls: "file-count-notice" });
      if (filteredFiles.length > displayLimit) {
        countDiv.textContent = `Showing ${filesToShow.length} of ${filteredFiles.length} files (${allMarkdownFiles.length} total)`;
      } else if (filteredFiles.length !== allMarkdownFiles.length) {
        countDiv.textContent = `Showing ${filesToShow.length} files (filtered from ${allMarkdownFiles.length} total)`;
      } else {
        countDiv.textContent = `Showing ${filesToShow.length} files`;
      }
    };
    let searchTimeout;
    searchInput.addEventListener("input", () => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(updateFileList, 300);
    });
    folderSelect.addEventListener("change", updateFileList);
    sortSelect.addEventListener("change", updateFileList);
    showSelectedOnly.addEventListener("change", updateFileList);
    updateFileList();
  }
  createFolderSelection() {
    const { contentEl } = this;
    const folderSection = contentEl.createDiv();
    folderSection.createEl("h3", { text: "Folders" });
    const folderList = folderSection.createDiv({ cls: "folder-selection-list" });
    const folders = this.getAllFolders();
    folders.forEach((folder) => {
      const folderItem = folderList.createDiv({ cls: "folder-item" });
      const checkbox = folderItem.createEl("input", { type: "checkbox" });
      checkbox.id = `folder-${folder.path}`;
      checkbox.addEventListener("change", (e) => {
        const target = e.target;
        console.log("Folder checkbox changed:", folder.path, "checked:", target.checked, "selection exists:", !!this.selection);
        if (!this.selection) {
          console.error("Selection object is undefined!");
          return;
        }
        if (target.checked) {
          this.selection.folders.push(folder.path);
        } else {
          this.selection.folders = this.selection.folders.filter((f) => f !== folder.path);
        }
        this.updatePreview();
      });
      const label = folderItem.createEl("label", {
        text: folder.name,
        attr: { for: `folder-${folder.path}` }
      });
      label.addClass("folder-label");
      const fileCount = this.getMarkdownFilesInFolder(folder).length;
      folderItem.createEl("span", {
        text: ` (${fileCount} files)`,
        cls: "file-count"
      });
    });
  }
  createTagSelection() {
    const { contentEl } = this;
    const tagSection = contentEl.createDiv();
    tagSection.createEl("h3", { text: "Tags" });
    const allTags = this.plugin.contentAggregator.getAllTags().slice(0, 30);
    const tagList = tagSection.createDiv({ cls: "tag-selection-list" });
    allTags.forEach((tag) => {
      const tagItem = tagList.createDiv({ cls: "tag-item" });
      const checkbox = tagItem.createEl("input", { type: "checkbox" });
      checkbox.id = `tag-${tag}`;
      checkbox.addEventListener("change", (e) => {
        const target = e.target;
        console.log("Tag checkbox changed:", tag, "checked:", target.checked, "selection exists:", !!this.selection);
        if (!this.selection) {
          console.error("Selection object is undefined!");
          return;
        }
        if (target.checked) {
          this.selection.tags.push(tag);
        } else {
          this.selection.tags = this.selection.tags.filter((t) => t !== tag);
        }
        this.updatePreview();
      });
      const label = tagItem.createEl("label", {
        text: `#${tag}`,
        attr: { for: `tag-${tag}` }
      });
      label.addClass("tag-label");
    });
  }
  createOptionsSection() {
    const { contentEl } = this;
    const optionsSection = contentEl.createDiv();
    optionsSection.createEl("h3", { text: "Options" });
    new import_obsidian3.Setting(optionsSection).setName("Include subfolders").setDesc("When selecting folders, include files from subfolders").addToggle((toggle) => toggle.setValue(this.selection.includeSubfolders).onChange((value) => {
      this.selection.includeSubfolders = value;
      this.updatePreview();
    }));
  }
  createPreviewSection() {
    var _a;
    const { contentEl } = this;
    const previewSection = contentEl.createDiv();
    previewSection.createEl("h3", { text: "Content Preview" });
    const previewEl = previewSection.createEl("div", { cls: "content-preview" });
    previewEl.style.maxHeight = "200px";
    previewEl.style.overflow = "auto";
    previewEl.style.border = "1px solid var(--background-modifier-border)";
    previewEl.style.padding = "10px";
    previewEl.style.backgroundColor = "var(--background-primary-alt)";
    (_a = this.contentEl.querySelector(".content-preview")) == null ? void 0 : _a.remove();
    previewSection.appendChild(previewEl);
  }
  createActionButtons() {
    const { contentEl } = this;
    const buttonSection = contentEl.createDiv({ cls: "modal-button-container" });
    buttonSection.style.display = "flex";
    buttonSection.style.gap = "10px";
    buttonSection.style.justifyContent = "flex-end";
    buttonSection.style.marginTop = "20px";
    const cancelButton = buttonSection.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const generateButton = buttonSection.createEl("button", { text: "Generate Mindmap" });
    generateButton.addClass("mod-cta");
    generateButton.addEventListener("click", () => {
      this.validateAndSubmit();
    });
  }
  async updatePreview() {
    const previewEl = this.contentEl.querySelector(".content-preview");
    if (!previewEl)
      return;
    if (!this.selection) {
      console.error("Selection object is undefined in updatePreview!");
      return;
    }
    try {
      const totalFiles = this.selection.files.length + this.selection.folders.reduce((count, folder) => {
        const folderObj = this.app.vault.getAbstractFileByPath(folder);
        return count + this.getMarkdownFilesInFolder(folderObj).length;
      }, 0);
      previewEl.innerHTML = `
        <div><strong>Selection Summary:</strong></div>
        <div>\u{1F4C4} Files: ${this.selection.files.length}</div>
        <div>\u{1F4C1} Folders: ${this.selection.folders.length}</div>
        <div>\u{1F3F7}\uFE0F Tags: ${this.selection.tags.length}</div>
        <div><strong>Total files to process: ${totalFiles}</strong></div>
        ${totalFiles > this.plugin.settings.maxSourceFiles ? `<div style="color: var(--text-error)">\u26A0\uFE0F This exceeds your limit of ${this.plugin.settings.maxSourceFiles} files</div>` : ""}
      `;
      if (totalFiles > 0 && totalFiles <= 10) {
        const preview = await this.plugin.contentAggregator.generateContentPreview(this.selection);
        if (preview) {
          previewEl.innerHTML += `<div style="margin-top: 10px;"><strong>Content Preview:</strong></div><div style="font-size: 0.9em; opacity: 0.8;">${preview}</div>`;
        }
      }
    } catch (error) {
      previewEl.innerHTML = '<div style="color: var(--text-error);">Error generating preview</div>';
    }
  }
  validateAndSubmit() {
    if (!this.selection) {
      console.error("Selection object is undefined in validateAndSubmit!");
      this.selection = {
        files: [],
        folders: [],
        tags: [],
        includeSubfolders: false,
        contentPreview: ""
      };
    }
    const totalFiles = this.selection.files.length + this.selection.folders.length + this.selection.tags.length;
    console.log("Validation - Selection details:", {
      files: this.selection.files,
      folders: this.selection.folders,
      tags: this.selection.tags,
      totalFiles
    });
    if (totalFiles === 0) {
      const errorEl = this.contentEl.createEl("div", {
        text: "Please select at least one file, folder, or tag",
        cls: "validation-error"
      });
      errorEl.style.color = "var(--text-error)";
      errorEl.style.marginTop = "10px";
      setTimeout(() => errorEl.remove(), 3e3);
      return;
    }
    this.close();
    this.onSubmit(this.selection);
  }
  getAllFolders() {
    const folders = [];
    const traverse = (folder) => {
      folders.push(folder);
      folder.children.forEach((child) => {
        if (child instanceof import_obsidian3.TFolder) {
          traverse(child);
        }
      });
    };
    this.app.vault.getAllLoadedFiles().forEach((file) => {
      if (file instanceof import_obsidian3.TFolder && file.path !== "/") {
        folders.push(file);
      }
    });
    return folders.sort((a, b) => a.path.localeCompare(b.path));
  }
  getMarkdownFilesInFolder(folder) {
    const files = [];
    const traverse = (currentFolder, includeSubfolders) => {
      currentFolder.children.forEach((child) => {
        if (child instanceof import_obsidian3.TFile && child.extension === "md") {
          files.push(child);
        } else if (child instanceof import_obsidian3.TFolder && includeSubfolders) {
          traverse(child, true);
        }
      });
    };
    traverse(folder, this.selection.includeSubfolders);
    return files;
  }
  getAllUniqueFolders() {
    const folders = /* @__PURE__ */ new Set();
    const markdownFiles = this.app.vault.getMarkdownFiles();
    markdownFiles.forEach((file) => {
      const folderPath = file.path.substring(0, file.path.lastIndexOf("/"));
      if (folderPath && folderPath !== file.path) {
        folders.add(folderPath);
        const parts = folderPath.split("/");
        for (let i = 1; i < parts.length; i++) {
          const parentPath = parts.slice(0, i + 1).join("/");
          folders.add(parentPath);
        }
      }
    });
    return Array.from(folders).sort();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/mindmapView.ts
var import_obsidian4 = require("obsidian");
var VIEW_TYPE_MINDMAP = "ai-mindmap-view";
var MindmapView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.mindmapData = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_MINDMAP;
  }
  getDisplayText() {
    return "AI Mindmap";
  }
  getIcon() {
    return "brain-circuit";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    if (this.mindmapData) {
      this.renderMindmap();
    } else {
      this.renderPlaceholder();
    }
  }
  async onClose() {
  }
  async setState(state, result) {
    if (state.mindmapData) {
      this.mindmapData = state.mindmapData;
      if (this.containerEl) {
        this.renderMindmap();
      }
    }
    return super.setState(state, result);
  }
  getState() {
    return {
      mindmapData: this.mindmapData
    };
  }
  renderPlaceholder() {
    const container = this.containerEl.children[1];
    container.empty();
    const placeholder = container.createDiv({ cls: "mindmap-placeholder" });
    placeholder.innerHTML = `
      <div style="text-align: center; padding: 50px; color: var(--text-muted);">
        <div style="font-size: 48px; margin-bottom: 20px;">\u{1F9E0}</div>
        <h3>AI Mindmap Generator</h3>
        <p>Generate a mindmap to view it here</p>
        <button class="mod-cta">Generate Mindmap</button>
      </div>
    `;
    const generateButton = placeholder.querySelector("button");
    generateButton == null ? void 0 : generateButton.addEventListener("click", () => {
      this.plugin.openSourceSelector();
    });
  }
  renderMindmap() {
    const container = this.containerEl.children[1];
    container.empty();
    if (!this.mindmapData) {
      this.renderPlaceholder();
      return;
    }
    const mindmapContainer = container.createDiv({ cls: "mindmap-container" });
    mindmapContainer.style.width = "100%";
    mindmapContainer.style.height = "100%";
    mindmapContainer.style.position = "relative";
    this.renderControls(mindmapContainer);
    const mindmapEl = mindmapContainer.createDiv({ cls: "mindmap-content" });
    mindmapEl.style.width = "100%";
    mindmapEl.style.height = "calc(100% - 60px)";
    mindmapEl.style.border = "1px solid var(--background-modifier-border)";
    mindmapEl.style.borderRadius = "8px";
    mindmapEl.style.overflow = "hidden";
    this.renderTreeView(mindmapEl);
    this.renderMetadataPanel(mindmapContainer);
  }
  renderControls(container) {
    const controls = container.createDiv({ cls: "mindmap-controls" });
    controls.style.display = "flex";
    controls.style.justifyContent = "space-between";
    controls.style.alignItems = "center";
    controls.style.padding = "10px";
    controls.style.borderBottom = "1px solid var(--background-modifier-border)";
    const leftControls = controls.createDiv();
    const rightControls = controls.createDiv();
    const zoomIn = leftControls.createEl("button", { text: "+" });
    const zoomOut = leftControls.createEl("button", { text: "-" });
    const resetView = leftControls.createEl("button", { text: "Reset" });
    zoomIn.style.marginRight = "5px";
    zoomOut.style.marginRight = "5px";
    resetView.style.marginRight = "10px";
    const exportMarkdown = rightControls.createEl("button", { text: "Export MD" });
    const exportImage = rightControls.createEl("button", { text: "Export PNG" });
    exportMarkdown.style.marginLeft = "5px";
    exportImage.style.marginLeft = "5px";
    exportMarkdown.addEventListener("click", () => this.exportAsMarkdown());
    exportImage.addEventListener("click", () => this.exportAsImage());
  }
  renderTreeView(container) {
    if (!this.mindmapData)
      return;
    const treeContainer = container.createDiv({ cls: "mindmap-tree" });
    treeContainer.style.padding = "20px";
    treeContainer.style.overflow = "auto";
    treeContainer.style.height = "100%";
    const nodeMap = new Map(this.mindmapData.nodes.map((node) => [node.id, node]));
    this.mindmapData.rootNodes.forEach((rootId) => {
      const rootNode = nodeMap.get(rootId);
      if (rootNode) {
        const rootEl = this.renderNode(rootNode, nodeMap, 0);
        treeContainer.appendChild(rootEl);
      }
    });
  }
  renderNode(node, nodeMap, depth) {
    const nodeEl = document.createElement("div");
    nodeEl.className = "mindmap-node";
    nodeEl.style.marginLeft = `${depth * 20}px`;
    nodeEl.style.marginBottom = "5px";
    const nodeContent = nodeEl.createDiv({ cls: "mindmap-node-content" });
    nodeContent.style.padding = "8px 12px";
    nodeContent.style.backgroundColor = depth === 0 ? "var(--interactive-accent)" : "var(--background-secondary)";
    nodeContent.style.borderRadius = "6px";
    nodeContent.style.cursor = "pointer";
    const label = nodeContent.createEl("strong", { text: node.label });
    if (depth === 0) {
      label.style.color = "var(--text-on-accent)";
    }
    if (node.tags.length > 0 || node.sourceNotes.length > 0) {
      const metadata = nodeContent.createDiv({ cls: "node-metadata" });
      metadata.style.fontSize = "0.8em";
      metadata.style.marginTop = "4px";
      metadata.style.opacity = "0.8";
      if (node.tags.length > 0) {
        metadata.createSpan({ text: `\u{1F3F7}\uFE0F ${node.tags.slice(0, 3).join(", ")}` });
      }
      if (node.sourceNotes.length > 0) {
        if (node.tags.length > 0)
          metadata.createEl("br");
        metadata.createSpan({ text: `\u{1F4C4} ${node.sourceNotes.length} sources` });
      }
    }
    if (node.parents.length > 1) {
      const multiParentIndicator = nodeContent.createDiv({ cls: "multi-parent-indicator" });
      multiParentIndicator.style.fontSize = "0.7em";
      multiParentIndicator.style.color = "var(--text-accent)";
      multiParentIndicator.style.marginTop = "2px";
      multiParentIndicator.textContent = `\u2197\uFE0F Connected to ${node.parents.length} parents`;
    }
    nodeContent.addEventListener("click", (e) => {
      e.stopPropagation();
      this.toggleNodeExpansion(nodeEl);
    });
    const childrenContainer = nodeEl.createDiv({ cls: "node-children" });
    node.children.forEach((childId) => {
      const childNode = nodeMap.get(childId);
      if (childNode) {
        const childEl = this.renderNode(childNode, nodeMap, depth + 1);
        childrenContainer.appendChild(childEl);
      }
    });
    return nodeEl;
  }
  toggleNodeExpansion(nodeEl) {
    const childrenContainer = nodeEl.querySelector(".node-children");
    if (childrenContainer) {
      if (childrenContainer.style.display === "none") {
        childrenContainer.style.display = "block";
      } else {
        childrenContainer.style.display = "none";
      }
    }
  }
  renderMetadataPanel(container) {
    if (!this.mindmapData)
      return;
    const panel = container.createDiv({ cls: "mindmap-metadata" });
    panel.style.position = "absolute";
    panel.style.top = "70px";
    panel.style.right = "10px";
    panel.style.width = "250px";
    panel.style.backgroundColor = "var(--background-secondary)";
    panel.style.border = "1px solid var(--background-modifier-border)";
    panel.style.borderRadius = "8px";
    panel.style.padding = "15px";
    panel.style.fontSize = "0.9em";
    const metadata = this.mindmapData.metadata;
    panel.innerHTML = `
      <h4 style="margin: 0 0 10px 0;">Mindmap Info</h4>
      <div><strong>Generated:</strong> ${new Date(metadata.generatedAt).toLocaleString()}</div>
      <div><strong>Sources:</strong> ${metadata.sourceCount} files</div>
      <div><strong>Tags:</strong> ${metadata.tagCount} unique</div>
      <div><strong>Nodes:</strong> ${this.mindmapData.nodes.length}</div>
      <div><strong>Model:</strong> ${metadata.llmProvider}</div>
    `;
  }
  async exportAsMarkdown() {
    if (!this.mindmapData)
      return;
    const markdown = this.plugin.mindmapGenerator.convertToMarkdown(this.mindmapData);
    const fileName = `AI Mindmap Export - ${new Date().toISOString().slice(0, 19).replace(/:/g, "-")}.md`;
    try {
      await this.app.vault.create(fileName, markdown);
      this.showNotification(`Exported as ${fileName}`, "success");
    } catch (error) {
      console.error("Export error:", error);
      this.showNotification("Export failed", "error");
    }
  }
  async exportAsImage() {
    this.showNotification("Image export coming soon!", "info");
  }
  showNotification(message, type) {
    const notification = this.containerEl.createDiv({ cls: `notification notification-${type}` });
    notification.textContent = message;
    notification.style.position = "fixed";
    notification.style.top = "20px";
    notification.style.right = "20px";
    notification.style.padding = "10px 15px";
    notification.style.borderRadius = "6px";
    notification.style.zIndex = "1000";
    switch (type) {
      case "success":
        notification.style.backgroundColor = "var(--color-green)";
        notification.style.color = "white";
        break;
      case "error":
        notification.style.backgroundColor = "var(--color-red)";
        notification.style.color = "white";
        break;
      case "info":
        notification.style.backgroundColor = "var(--interactive-accent)";
        notification.style.color = "var(--text-on-accent)";
        break;
    }
    setTimeout(() => {
      notification.remove();
    }, 3e3);
  }
};

// src/components/visualMindmapView.ts
var import_obsidian5 = require("obsidian");
var VIEW_TYPE_VISUAL_MINDMAP = "ai-visual-mindmap-view";
var VisualMindmapView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.mindmapData = null;
    this.markmap = null;
    this.markmapAssets = false;
    this.currentSourceFiles = [];
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_VISUAL_MINDMAP;
  }
  getDisplayText() {
    return "AI Visual Mindmap";
  }
  getIcon() {
    return "brain-circuit";
  }
  async onOpen() {
    await this.loadMarkmapAssets();
    const container = this.containerEl.children[1];
    container.empty();
    if (this.mindmapData) {
      await this.renderVisualMindmap();
    } else {
      this.renderPlaceholder();
    }
  }
  async onClose() {
    console.log("Visual mindmap view closing but preserving mindmap instance");
  }
  async setState(state, result) {
    if (state.mindmapData) {
      this.mindmapData = state.mindmapData;
      this.currentSourceFiles = state.sourceFiles || [];
      if (this.containerEl) {
        await this.renderVisualMindmap();
      }
    }
    return super.setState(state, result);
  }
  setMindmapData(mindmapData, sourceFiles = []) {
    this.mindmapData = mindmapData;
    this.currentSourceFiles = sourceFiles;
  }
  getState() {
    return {
      mindmapData: this.mindmapData
    };
  }
  async loadMarkmapAssets() {
    if (this.markmapAssets)
      return;
    try {
      console.log("Loading markmap assets...");
      await this.loadScript("https://cdn.jsdelivr.net/npm/d3@7");
      console.log("D3 loaded");
      await this.loadScript("https://cdn.jsdelivr.net/npm/markmap-lib@0.15.3/dist/browser/index.js");
      console.log("Markmap lib loaded");
      await this.loadScript("https://cdn.jsdelivr.net/npm/markmap-view@0.15.3/dist/browser/index.js");
      console.log("Markmap view loaded");
      this.addMarkmapStyles();
      this.markmapAssets = true;
      console.log("Markmap assets loaded successfully");
      if (window.markmap) {
        console.log("Markmap library is available:", Object.keys(window.markmap));
      } else {
        console.error("Markmap library not available on window object");
      }
    } catch (error) {
      console.error("Failed to load markmap assets:", error);
    }
  }
  addMarkmapStyles() {
    const style = document.createElement("style");
    style.textContent = `
      .ai-mindmap-container {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      .ai-mindmap-svg {
        width: 100%;
        height: 100%;
        background: var(--background-primary);
      }
      .mm-node {
        cursor: pointer;
      }
      .mm-node circle {
        stroke-width: 1.5px;
        stroke: var(--interactive-accent);
        fill: var(--background-primary);
      }
      .mm-node text {
        font-family: var(--font-interface);
        font-size: 13px;
        fill: var(--text-normal);
        font-weight: 500;
      }
      .mm-node:hover circle {
        stroke-width: 2px;
        fill: var(--interactive-accent-hover);
      }
      .mm-node:hover text {
        fill: var(--text-accent);
        font-weight: 600;
      }
      .mm-link {
        stroke-width: 1.5px;
        fill: none;
        stroke: var(--text-muted);
        stroke-opacity: 0.7;
      }
      .mm-branch {
        stroke: var(--interactive-accent);
        stroke-width: 2px;
      }
      /* Force readable layout */
      .markmap-node {
        max-width: 120px !important;
      }
      .markmap-foreign {
        font-size: 14px !important;
        font-family: var(--font-interface) !important;
      }
      .markmap-node text {
        font-size: 14px !important;
        font-family: var(--font-interface) !important;
      }
      /* Force minimum zoom level */
      svg.ai-mindmap-svg {
        min-width: 200% !important;
        min-height: 200% !important;
        transform-origin: center !important;
      }
      /* Compact branches */
      .mm-branch,
      .markmap-link {
        stroke-width: 1.5px !important;
      }
    `;
    document.head.appendChild(style);
  }
  loadScript(src) {
    return new Promise((resolve, reject) => {
      if (document.querySelector(`script[src="${src}"]`)) {
        resolve();
        return;
      }
      const script = document.createElement("script");
      script.src = src;
      script.onload = () => resolve();
      script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
      document.head.appendChild(script);
    });
  }
  renderPlaceholder() {
    const container = this.containerEl.children[1];
    container.empty();
    const placeholder = container.createDiv({ cls: "mindmap-placeholder" });
    placeholder.innerHTML = `
      <div style="text-align: center; padding: 50px; color: var(--text-muted);">
        <div style="font-size: 48px; margin-bottom: 20px;">\u{1F9E0}</div>
        <h3>AI Visual Mindmap</h3>
        <p>Generate a mindmap to view it here</p>
        <button class="mod-cta">Generate Mindmap</button>
      </div>
    `;
    const generateButton = placeholder.querySelector("button");
    generateButton == null ? void 0 : generateButton.addEventListener("click", () => {
      this.plugin.openSourceSelector();
    });
  }
  async renderVisualMindmap() {
    const container = this.containerEl.children[1];
    container.empty();
    if (!this.mindmapData) {
      this.renderPlaceholder();
      return;
    }
    const mindmapContainer = container.createDiv({ cls: "ai-mindmap-container" });
    mindmapContainer.style.width = "100%";
    mindmapContainer.style.height = "100%";
    mindmapContainer.style.position = "relative";
    this.renderControls(mindmapContainer);
    const svgContainer = mindmapContainer.createDiv({ cls: "mindmap-svg-container" });
    svgContainer.style.width = "100%";
    svgContainer.style.height = "calc(100% - 60px)";
    svgContainer.style.border = "1px solid var(--background-modifier-border)";
    svgContainer.style.borderRadius = "8px";
    svgContainer.style.overflow = "hidden";
    svgContainer.style.background = "var(--background-primary)";
    const svg = svgContainer.createSvg("svg");
    svg.addClass("ai-mindmap-svg");
    svg.style.width = "100%";
    svg.style.height = "100%";
    const markdown = this.convertToMarkdown();
    try {
      if (!window.markmap) {
        console.warn("Markmap not available, falling back to text view");
        this.renderFallbackView(svgContainer);
        return;
      }
      const transformer = new window.markmap.Transformer();
      const { root } = transformer.transform(markdown);
      console.log("Markmap data generated:", root);
      if (this.markmap) {
        this.markmap.destroy();
      }
      const { Markmap } = window.markmap;
      this.markmap = Markmap.create(svg, {
        // Force very small coordinate space
        maxWidth: 120,
        spacingHorizontal: 6,
        spacingVertical: 2,
        fitRatio: 1.2,
        // Allow larger fitting
        pan: true,
        zoom: true,
        // Minimal padding
        paddingX: 1,
        paddingY: 1,
        autoFit: true,
        // Readable text
        nodeFont: "14px var(--font-interface)",
        nodeMinHeight: 20,
        initialExpandLevel: 2,
        embedGlobalCSS: false,
        // Force tight layout
        duration: 0
      });
      this.markmap.setData(root);
      setTimeout(() => {
        this.markmap.rescale(4);
        this.markmap.fit();
        console.log("Mindmap rendered with 4x zoom, adding click handlers...");
        this.addNodeClickHandlers();
      }, 300);
    } catch (error) {
      console.error("Error creating markmap:", error);
      this.renderFallbackView(svgContainer);
    }
    this.renderMetadataPanel(mindmapContainer);
  }
  convertToMarkdown() {
    if (!this.mindmapData)
      return "";
    console.log("Converting mindmap data to markdown for visual mindmap:", {
      totalNodes: this.mindmapData.nodes.length,
      rootNodes: this.mindmapData.rootNodes.length,
      nodeDetails: this.mindmapData.nodes.map((n) => ({
        id: n.id,
        label: n.label,
        level: n.level,
        childrenCount: n.children.length,
        children: n.children
      }))
    });
    const nodeMap = new Map(this.mindmapData.nodes.map((node) => [node.id, node]));
    let markdown = "";
    this.mindmapData.rootNodes.forEach((rootId) => {
      const rootNode = nodeMap.get(rootId);
      if (rootNode) {
        console.log(`Processing root node: ${rootNode.label} with ${rootNode.children.length} children`);
        markdown += this.generateNextGenNodeMarkdown(rootNode, nodeMap, 1);
      }
    });
    console.log("Generated markdown:", markdown);
    return markdown || "# No Content Generated";
  }
  generateNextGenNodeMarkdown(node, nodeMap, headingLevel) {
    console.log(`Generating NextGen markdown for node "${node.label}" at heading level ${headingLevel} with ${node.children.length} children`);
    const headingPrefix = "#".repeat(Math.min(headingLevel, 6));
    let markdown = `${headingPrefix} ${node.label}
`;
    node.children.forEach((childId) => {
      const childNode = nodeMap.get(childId);
      if (childNode) {
        markdown += this.generateNextGenNodeMarkdown(childNode, nodeMap, headingLevel + 1);
      }
    });
    return markdown;
  }
  generateNodeMarkdown(node, nodeMap, depth) {
    console.log(`Generating markdown for node "${node.label}" at depth ${depth} with ${node.children.length} children`);
    const prefix = depth === 0 ? "# " : "  ".repeat(depth - 1) + "- ";
    let markdown = `${prefix}${node.label}`;
    if (node.tags.length > 0 || node.sourceNotes.length > 0) {
      const metadata = [];
      if (node.tags.length > 0) {
        metadata.push(`\u{1F3F7}\uFE0F${node.tags.slice(0, 2).join(",")}`);
      }
      if (node.sourceNotes.length > 0) {
        metadata.push(`\u{1F4C4}${node.sourceNotes.length}`);
      }
      markdown += ` <small>(${metadata.join(" | ")})</small>`;
    }
    markdown += "\n";
    node.children.forEach((childId) => {
      const childNode = nodeMap.get(childId);
      if (childNode) {
        console.log(`Adding child "${childNode.label}" to parent "${node.label}"`);
        markdown += this.generateNodeMarkdown(childNode, nodeMap, depth + 1);
      } else {
        console.warn(`Child node with ID ${childId} not found in nodeMap`);
      }
    });
    return markdown;
  }
  forceCompactSpacing() {
    console.log("Forcing compact spacing...");
    if (!this.markmap || !this.markmap.svg) {
      console.warn("Markmap or SVG not available for spacing adjustment");
      return;
    }
    try {
      const svg = this.markmap.svg;
      const nodeGroups = svg.selectAll("g[data-depth]");
      console.log(`Found ${nodeGroups.size()} node groups for spacing adjustment`);
      nodeGroups.each(function(d) {
        if (d && d.data) {
          const element = this;
          const transform = element.getAttribute("transform");
          if (transform && transform.includes("translate")) {
            const match = transform.match(/translate\(([^,]+),([^)]+)\)/);
            if (match) {
              const currentX = parseFloat(match[1]);
              const currentY = parseFloat(match[2]);
              const newX = currentX * 0.4;
              const newTransform = transform.replace(
                /translate\([^)]+\)/,
                `translate(${newX},${currentY})`
              );
              element.setAttribute("transform", newTransform);
            }
          }
        }
      });
      const textElements = svg.selectAll("text");
      textElements.each(function() {
        const element = this;
        element.style.fontSize = "11px";
        element.style.fontFamily = "var(--font-interface)";
      });
      console.log("Spacing adjustment completed");
    } catch (error) {
      console.error("Error adjusting spacing:", error);
    }
  }
  addNodeClickHandlers() {
    if (!this.markmap)
      return;
    console.log("Adding click handlers to markmap nodes");
    const attempts = [300, 600, 1e3, 1500];
    attempts.forEach((delay, index) => {
      setTimeout(() => {
        console.log(`Attempt ${index + 1} to add click handlers (${delay}ms delay)...`);
        this.attemptToAddClickHandlers();
      }, delay);
    });
  }
  attemptToAddClickHandlers() {
    if (!this.markmap || !this.markmap.svg) {
      console.log("Markmap or SVG not available");
      return;
    }
    const nodeSelectors = [
      ".mm-node",
      ".markmap-node",
      "g[data-depth]",
      "g.mm-node",
      "g.markmap-node",
      '[data-testid="markmap-node"]',
      "g:has(circle)",
      "g:has(text)",
      "g > circle",
      "circle",
      "text"
    ];
    let successfulHandlers = 0;
    nodeSelectors.forEach((selector) => {
      try {
        const elements = this.markmap.svg.selectAll(selector);
        const count = elements.size();
        console.log(`Selector "${selector}": found ${count} elements`);
        if (count > 0) {
          elements.on("click", (event, d) => {
            console.log(`Element clicked via selector "${selector}":`, {
              data: d,
              event,
              target: event.target,
              currentTarget: event.currentTarget
            });
            event.stopPropagation();
            this.handleNodeClick(d, event);
          });
          successfulHandlers += count;
        }
      } catch (error) {
        console.log(`Selector "${selector}" failed:`, error.message);
      }
    });
    try {
      this.markmap.svg.on("click", (event) => {
        console.log("SVG click detected:", event);
        let target = event.target;
        let nodeData = null;
        while (target && target !== this.markmap.svg.node()) {
          if (target.__data__) {
            nodeData = target.__data__;
            break;
          }
          target = target.parentNode;
        }
        if (nodeData) {
          console.log("Found node data via delegation:", nodeData);
          event.stopPropagation();
          this.handleNodeClick(nodeData, event);
        }
      });
      console.log("Added delegated click handler to SVG");
    } catch (error) {
      console.log("Failed to add delegated handler:", error.message);
    }
    try {
      const svgElement = this.markmap.svg.node();
      if (svgElement) {
        const nativeHandler = (event) => {
          console.log("Native click handler triggered:", event.target);
          let element = event.target;
          let nodeData = null;
          while (element && element !== svgElement) {
            if (element.__data__) {
              nodeData = element.__data__;
              break;
            }
            element = element.parentElement || element.parentNode;
          }
          if (nodeData) {
            console.log("Found node data via native handler:", nodeData);
            event.stopPropagation();
            this.handleNodeClick(nodeData, event);
          }
        };
        svgElement.addEventListener("click", nativeHandler);
        console.log("Added native DOM click handler");
      }
    } catch (error) {
      console.log("Failed to add native handler:", error.message);
    }
    if (successfulHandlers > 0) {
      console.log(`Successfully added click handlers to ${successfulHandlers} elements`);
    } else {
      this.debugSVGStructure();
    }
  }
  debugSVGStructure() {
    if (!this.markmap || !this.markmap.svg)
      return;
    console.log("=== SVG Structure Debug ===");
    const svgElement = this.markmap.svg.node();
    if (svgElement) {
      console.log("SVG element:", svgElement);
      console.log("SVG innerHTML (first 500 chars):", svgElement.innerHTML.substring(0, 500));
      const children = Array.from(svgElement.children);
      console.log(`SVG has ${children.length} direct children:`, children.map((c) => c.tagName));
      const elementsWithData = svgElement.querySelectorAll("*");
      let dataElements = 0;
      elementsWithData.forEach((el) => {
        if (el.__data__) {
          dataElements++;
          console.log("Element with data:", el.tagName, el.__data__);
        }
      });
      console.log(`Found ${dataElements} elements with __data__ property`);
      const markmapElements = svgElement.querySelectorAll('[class*="mm"], [class*="markmap"], [data-depth], circle, text');
      console.log(
        `Found ${markmapElements.length} potential markmap elements:`,
        Array.from(markmapElements).map((el) => {
          const element = el;
          return `${element.tagName}${element.className ? "." + element.className : ""}`;
        })
      );
    }
    console.log("=== End SVG Structure Debug ===");
  }
  handleNodeClick(nodeData, event) {
    var _a, _b;
    console.log("Handling node click with data:", nodeData);
    let nodeText = "";
    if ((_a = nodeData == null ? void 0 : nodeData.data) == null ? void 0 : _a.content) {
      nodeText = nodeData.data.content;
    } else if (nodeData == null ? void 0 : nodeData.content) {
      nodeText = nodeData.content;
    } else if ((_b = nodeData == null ? void 0 : nodeData.data) == null ? void 0 : _b.value) {
      nodeText = nodeData.data.value;
    } else if (nodeData == null ? void 0 : nodeData.value) {
      nodeText = nodeData.value;
    } else if (typeof nodeData === "string") {
      nodeText = nodeData;
    }
    console.log("Extracted node text:", nodeText);
    if (nodeText) {
      this.showNodeDetails({ data: { content: nodeText } });
    } else {
      console.log("Could not extract text from node data, showing raw data");
      this.showNodeDetails(nodeData);
    }
  }
  showNodeDetails(nodeData) {
    var _a;
    const node = this.findNodeByLabel(nodeData.data.content);
    if (!node)
      return;
    const sourceFilesHtml = node.sourceNotes.length > 0 ? `<p><strong>Source Files:</strong></p>
       <ul class="source-files-list">
         ${node.sourceNotes.map(
      (filePath) => `<li><a href="#" class="source-file-link" data-file="${filePath}">${this.getFileDisplayName(filePath)}</a></li>`
    ).join("")}
       </ul>` : "";
    const popup = document.createElement("div");
    popup.className = "mindmap-node-popup";
    popup.innerHTML = `
      <div class="popup-header">
        <strong>${node.label}</strong>
        <button class="popup-close">\xD7</button>
      </div>
      <div class="popup-content">
        ${node.content ? `<p><strong>Summary:</strong> ${node.content.substring(0, 200)}...</p>` : ""}
        ${node.tags.length > 0 ? `<p><strong>Tags:</strong> ${node.tags.join(", ")}</p>` : ""}
        ${sourceFilesHtml}
        ${node.parents.length > 1 ? `<p><strong>Multi-parent node</strong> (${node.parents.length} connections)</p>` : ""}
      </div>
    `;
    popup.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--background-primary);
      border: 1px solid var(--background-modifier-border);
      border-radius: 8px;
      padding: 0;
      max-width: 400px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 1000;
    `;
    this.containerEl.appendChild(popup);
    (_a = popup.querySelector(".popup-close")) == null ? void 0 : _a.addEventListener("click", () => {
      popup.remove();
    });
    popup.querySelectorAll(".source-file-link").forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();
        const filePath = e.target.getAttribute("data-file");
        if (filePath) {
          this.openSourceFile(filePath);
        }
      });
    });
    setTimeout(() => {
      document.addEventListener("click", function closePopup(e) {
        if (!popup.contains(e.target)) {
          popup.remove();
          document.removeEventListener("click", closePopup);
        }
      });
    }, 100);
  }
  findNodeByLabel(label) {
    if (!this.mindmapData)
      return null;
    return this.mindmapData.nodes.find((node) => node.label === label.split("<small>")[0].trim());
  }
  getFileDisplayName(filePath) {
    const parts = filePath.split("/");
    const fileName = parts[parts.length - 1];
    return fileName.replace(/\.md$/, "");
  }
  async openSourceFile(filePath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file) {
        const leaf = this.app.workspace.getLeaf(true);
        await leaf.openFile(file);
        this.app.workspace.revealLeaf(leaf);
        this.showNotification(`Opened: ${this.getFileDisplayName(filePath)}`, "success");
      } else {
        this.showNotification(`File not found: ${filePath}`, "error");
      }
    } catch (error) {
      console.error("Error opening file:", error);
      this.showNotification(`Error opening file: ${error.message}`, "error");
    }
  }
  renderFallbackView(container) {
    container.innerHTML = `
      <div style="padding: 20px; text-align: center; color: var(--text-muted);">
        <p>Could not render visual mindmap. Falling back to text view.</p>
        <div style="text-align: left; margin-top: 20px; font-family: monospace; font-size: 0.9em;">
          <pre>${this.convertToMarkdown()}</pre>
        </div>
      </div>
    `;
  }
  renderControls(container) {
    const controls = container.createDiv({ cls: "mindmap-controls" });
    controls.style.display = "flex";
    controls.style.justifyContent = "space-between";
    controls.style.alignItems = "center";
    controls.style.padding = "10px";
    controls.style.borderBottom = "1px solid var(--background-modifier-border)";
    controls.style.backgroundColor = "var(--background-secondary)";
    const leftControls = controls.createDiv();
    const rightControls = controls.createDiv();
    const fitButton = leftControls.createEl("button", { text: "Fit" });
    const centerButton = leftControls.createEl("button", { text: "Center" });
    const expandAllButton = leftControls.createEl("button", { text: "Expand All" });
    fitButton.style.marginRight = "5px";
    centerButton.style.marginRight = "5px";
    expandAllButton.style.marginRight = "10px";
    const saveButton = rightControls.createEl("button", { text: "Save Mindmap" });
    const exportSvg = rightControls.createEl("button", { text: "Export SVG" });
    const exportMd = rightControls.createEl("button", { text: "Export MD" });
    saveButton.style.marginLeft = "5px";
    saveButton.style.backgroundColor = "var(--interactive-accent)";
    saveButton.style.color = "var(--text-on-accent)";
    exportSvg.style.marginLeft = "5px";
    exportMd.style.marginLeft = "5px";
    fitButton.addEventListener("click", () => {
      var _a;
      return (_a = this.markmap) == null ? void 0 : _a.fit();
    });
    centerButton.addEventListener("click", () => {
      var _a, _b;
      return (_b = this.markmap) == null ? void 0 : _b.setData((_a = this.markmap) == null ? void 0 : _a.data);
    });
    expandAllButton.addEventListener("click", () => {
      if (this.markmap) {
        this.markmap.svg.selectAll(".mm-node").each((d) => {
          d.data.payload = { ...d.data.payload, fold: false };
        });
        this.markmap.setData(this.markmap.data);
      }
    });
    saveButton.addEventListener("click", () => this.showSaveMindmapModal());
    exportSvg.addEventListener("click", () => this.exportAsSVG());
    exportMd.addEventListener("click", () => this.exportAsMarkdown());
  }
  renderMetadataPanel(container) {
    if (!this.mindmapData)
      return;
    const panel = container.createDiv({ cls: "mindmap-metadata" });
    panel.style.position = "absolute";
    panel.style.top = "70px";
    panel.style.right = "10px";
    panel.style.width = "250px";
    panel.style.backgroundColor = "var(--background-secondary)";
    panel.style.border = "1px solid var(--background-modifier-border)";
    panel.style.borderRadius = "8px";
    panel.style.padding = "15px";
    panel.style.fontSize = "0.9em";
    panel.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.1)";
    const metadata = this.mindmapData.metadata;
    panel.innerHTML = `
      <h4 style="margin: 0 0 10px 0; color: var(--text-accent);">Mindmap Info</h4>
      <div><strong>Generated:</strong> ${new Date(metadata.generatedAt).toLocaleString()}</div>
      <div><strong>Sources:</strong> ${metadata.sourceCount} files</div>
      <div><strong>Tags:</strong> ${metadata.tagCount} unique</div>
      <div><strong>Nodes:</strong> ${this.mindmapData.nodes.length}</div>
      <div><strong>Model:</strong> ${metadata.llmProvider}</div>
      <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--background-modifier-border);">
        <small><strong>Click nodes</strong> for details<br>
        <strong>Scroll</strong> to zoom<br>
        <strong>Drag</strong> to pan</small>
      </div>
    `;
  }
  async exportAsSVG() {
    if (!this.markmap || !this.mindmapData)
      return;
    try {
      const svgElement = this.markmap.svg.node();
      if (!svgElement)
        return;
      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(svgElement);
      const fileName = `AI-Mindmap-${Date.now()}.svg`;
      const blob = new Blob([svgString], { type: "image/svg+xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
      this.showNotification(`SVG exported as ${fileName}`, "success");
    } catch (error) {
      console.error("SVG export failed:", error);
      this.showNotification("SVG export failed", "error");
    }
  }
  async exportAsMarkdown() {
    if (!this.mindmapData)
      return;
    const markdown = this.plugin.mindmapGenerator.convertToMarkdown(this.mindmapData);
    const fileName = `AI-Mindmap-Export-${Date.now()}.md`;
    try {
      await this.app.vault.create(fileName, markdown);
      this.showNotification(`Exported as ${fileName}`, "success");
    } catch (error) {
      console.error("Markdown export failed:", error);
      this.showNotification("Markdown export failed", "error");
    }
  }
  showSaveMindmapModal() {
    if (!this.mindmapData) {
      this.showNotification("No mindmap to save", "error");
      return;
    }
    const modal = new SaveMindmapModal(this.app, this.mindmapData, this.currentSourceFiles, (savedId) => {
      if (savedId) {
        this.showNotification("Mindmap saved successfully", "success");
      }
    });
    modal.open();
  }
  showNotification(message, type) {
    const notification = document.createElement("div");
    notification.className = `notification notification-${type}`;
    notification.textContent = message;
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px 15px;
      border-radius: 6px;
      z-index: 1000;
      color: white;
      font-weight: 500;
      background-color: ${type === "success" ? "#22C55E" : type === "error" ? "#EF4444" : "#3B82F6"};
    `;
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.remove();
    }, 3e3);
  }
};
var SaveMindmapModal = class extends import_obsidian5.Modal {
  constructor(app, mindmapData, sourceFiles, onSave) {
    super(app);
    this.mindmapData = mindmapData;
    this.sourceFiles = sourceFiles;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Save Mindmap" });
    const suggestedName = this.generateSuggestedName();
    new import_obsidian5.Setting(contentEl).setName("Mindmap Name").setDesc("Enter a name for this mindmap").addText((text) => {
      this.nameInput = text.inputEl;
      text.setValue(suggestedName);
      text.inputEl.style.width = "100%";
    });
    new import_obsidian5.Setting(contentEl).setName("Description (optional)").setDesc("Add a description for this mindmap").addTextArea((text) => {
      this.descriptionInput = text.inputEl;
      text.inputEl.style.width = "100%";
      text.inputEl.style.minHeight = "80px";
      text.setValue(`Generated from ${this.sourceFiles.length} source files on ${new Date().toLocaleDateString()}`);
    });
    const previewEl = contentEl.createDiv();
    previewEl.style.marginTop = "20px";
    previewEl.style.padding = "10px";
    previewEl.style.backgroundColor = "var(--background-secondary)";
    previewEl.style.borderRadius = "6px";
    previewEl.createEl("h4", { text: "Preview:" });
    previewEl.createEl("div", {
      text: `\u{1F4CA} ${this.mindmapData.nodes.length} nodes, ${this.sourceFiles.length} source files`
    });
    previewEl.createEl("div", {
      text: `\u{1F5D3}\uFE0F Generated: ${new Date(this.mindmapData.metadata.generatedAt).toLocaleString()}`
    });
    previewEl.createEl("div", {
      text: `\u{1F916} Model: ${this.mindmapData.metadata.llmProvider}`
    });
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.marginTop = "20px";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const saveButton = buttonContainer.createEl("button", { text: "Save Mindmap" });
    saveButton.addClass("mod-cta");
    saveButton.addEventListener("click", () => {
      this.saveMindmap();
    });
    setTimeout(() => {
      this.nameInput.focus();
      this.nameInput.select();
    }, 100);
  }
  generateSuggestedName() {
    const timestamp = new Date().toLocaleDateString();
    const fileCount = this.sourceFiles.length;
    const commonFolders = this.findCommonFolder(this.sourceFiles);
    const folderName = commonFolders ? commonFolders.split("/").pop() : "Mixed";
    return `${folderName} Analysis (${fileCount} files) - ${timestamp}`;
  }
  findCommonFolder(files) {
    if (files.length === 0)
      return null;
    const folders = files.map((file) => {
      const lastSlash = file.lastIndexOf("/");
      return lastSlash > 0 ? file.substring(0, lastSlash) : "";
    });
    const folderCounts = folders.reduce((acc, folder) => {
      acc[folder] = (acc[folder] || 0) + 1;
      return acc;
    }, {});
    const mostCommon = Object.entries(folderCounts).sort((a, b) => b[1] - a[1])[0];
    return mostCommon && mostCommon[1] > 1 ? mostCommon[0] : null;
  }
  async saveMindmap() {
    console.log("SaveMindmapModal: Starting save process...");
    const name = this.nameInput.value.trim();
    const description = this.descriptionInput.value.trim();
    console.log("SaveMindmapModal: Name:", name);
    console.log("SaveMindmapModal: Description:", description);
    console.log("SaveMindmapModal: MindmapData exists:", !!this.mindmapData);
    console.log("SaveMindmapModal: Source files count:", this.sourceFiles.length);
    if (!name) {
      console.log("SaveMindmapModal: No name provided");
      const errorEl = this.contentEl.createEl("div", {
        text: "Please enter a name for the mindmap",
        cls: "validation-error"
      });
      errorEl.style.color = "var(--text-error)";
      errorEl.style.marginTop = "10px";
      setTimeout(() => errorEl.remove(), 3e3);
      return;
    }
    try {
      console.log("SaveMindmapModal: Looking for plugin instance...");
      const plugin = this.app.plugins.plugins["ai-mindmap-generator"];
      console.log("SaveMindmapModal: Plugin found:", !!plugin);
      console.log("SaveMindmapModal: Plugin type:", typeof plugin);
      if (plugin) {
        console.log("SaveMindmapModal: Persistence service exists:", !!plugin.persistenceService);
        console.log("SaveMindmapModal: Persistence service type:", typeof plugin.persistenceService);
      }
      if (!plugin || !plugin.persistenceService) {
        throw new Error("Persistence service not available - plugin or service is null");
      }
      console.log("SaveMindmapModal: Calling persistenceService.saveMindmap...");
      const savedId = await plugin.persistenceService.saveMindmap(
        this.mindmapData,
        this.sourceFiles,
        name,
        description || void 0
      );
      console.log("SaveMindmapModal: Save completed with ID:", savedId);
      this.onSave(savedId);
      this.close();
    } catch (error) {
      console.error("SaveMindmapModal: Failed to save mindmap:", error);
      console.error("SaveMindmapModal: Error message:", error.message);
      console.error("SaveMindmapModal: Error stack:", error.stack);
      const errorEl = this.contentEl.createEl("div", {
        text: `Failed to save: ${error.message}`,
        cls: "validation-error"
      });
      errorEl.style.color = "var(--text-error)";
      errorEl.style.marginTop = "10px";
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/components/mindmapCombinerModal.ts
var import_obsidian6 = require("obsidian");
var MindmapCombinerModal = class extends import_obsidian6.Modal {
  constructor(app, plugin) {
    super(app);
    this.selectedMindmaps = /* @__PURE__ */ new Set();
    this.allMindmaps = [];
    this.filteredMindmaps = [];
    this.searchTerm = "";
    this.sortBy = "date";
    this.combinedName = "";
    this.plugin = plugin;
    this.combineOptions = {
      preserveSourceAttribution: true,
      enableSemanticDeduplication: false,
      maxSimilarityThreshold: 0.8,
      conflictResolutionStrategy: "exact_match" /* EXACT_MATCH */,
      maintainSteepleStructure: true,
      generateCombinedName: true,
      deduplicateSourceLinks: true
    };
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u{1F517} Combine Mindmaps" });
    contentEl.createEl("p", {
      text: "Select multiple mindmaps to combine into a single comprehensive mindmap. Useful for processing large amounts of content in batches.",
      cls: "mod-muted"
    });
    this.loadMindmaps();
    this.render();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  async loadMindmaps() {
    try {
      this.allMindmaps = await this.plugin.persistenceService.getAllMindmaps();
      this.filterAndSortMindmaps();
      console.log(`Loaded ${this.allMindmaps.length} mindmaps for combination from directory`);
      this.render();
    } catch (error) {
      console.error("Failed to load mindmaps:", error);
      new import_obsidian6.Notice("Failed to load saved mindmaps");
    }
  }
  filterAndSortMindmaps() {
    let filtered = this.allMindmaps.filter((mindmap) => {
      var _a;
      if (!this.searchTerm)
        return true;
      const searchLower = this.searchTerm.toLowerCase();
      return mindmap.name.toLowerCase().includes(searchLower) || ((_a = mindmap.description) == null ? void 0 : _a.toLowerCase().includes(searchLower)) || mindmap.metadata.steepleCategories.some((cat) => cat.toLowerCase().includes(searchLower)) || mindmap.sourceFiles.some((file) => file.toLowerCase().includes(searchLower));
    });
    switch (this.sortBy) {
      case "name":
        filtered.sort((a, b) => a.name.localeCompare(b.name));
        break;
      case "sources":
        filtered.sort((a, b) => b.sourceCount - a.sourceCount);
        break;
      case "date":
      default:
        filtered.sort((a, b) => new Date(b.modifiedAt).getTime() - new Date(a.modifiedAt).getTime());
        break;
    }
    this.filteredMindmaps = filtered;
  }
  render() {
    const { contentEl } = this;
    const existing = contentEl.querySelector(".mindmap-combiner-content");
    if (existing)
      existing.remove();
    const container = contentEl.createDiv({ cls: "mindmap-combiner-content" });
    if (this.allMindmaps.length === 0) {
      container.createEl("p", {
        text: "No saved mindmaps found. Generate some mindmaps first to combine them.",
        cls: "mod-muted"
      });
      return;
    }
    const controlsContainer = container.createDiv({ cls: "mindmap-controls" });
    controlsContainer.style.marginBottom = "15px";
    new import_obsidian6.Setting(controlsContainer).setName("Search Mindmaps").setDesc("Search by name, description, categories, or source files").addText((text) => text.setPlaceholder("Type to search...").setValue(this.searchTerm).onChange((value) => {
      this.searchTerm = value;
      this.filterAndSortMindmaps();
      this.render();
    }));
    new import_obsidian6.Setting(controlsContainer).setName("Sort By").addDropdown((dropdown) => dropdown.addOption("date", "Date Modified (newest first)").addOption("name", "Name (A-Z)").addOption("sources", "Source Count (most first)").setValue(this.sortBy).onChange((value) => {
      this.sortBy = value;
      this.filterAndSortMindmaps();
      this.render();
    }));
    new import_obsidian6.Setting(container).setName("Combined Mindmap Name").setDesc("Name for the new combined mindmap").addText((text) => text.setPlaceholder("Enter name or leave blank for auto-generation").setValue(this.combinedName).onChange((value) => {
      this.combinedName = value;
    }));
    container.createEl("h3", { text: "Select Mindmaps to Combine" });
    container.createEl("p", {
      text: `Choose at least 2 mindmaps to combine (${this.selectedMindmaps.size} selected, ${this.filteredMindmaps.length} showing)`,
      cls: "mod-muted"
    });
    const mindmapList = container.createDiv({ cls: "mindmap-list" });
    const buttonContainer = mindmapList.createDiv({ cls: "button-container" });
    buttonContainer.style.marginBottom = "10px";
    const selectAllBtn = buttonContainer.createEl("button", {
      text: `Select All (${this.filteredMindmaps.length})`,
      cls: "mod-muted"
    });
    selectAllBtn.addEventListener("click", () => {
      this.filteredMindmaps.forEach((mindmap) => this.selectedMindmaps.add(mindmap.id));
      this.render();
    });
    const clearAllBtn = buttonContainer.createEl("button", {
      text: "Clear All",
      cls: "mod-muted"
    });
    clearAllBtn.style.marginLeft = "10px";
    clearAllBtn.addEventListener("click", () => {
      this.selectedMindmaps.clear();
      this.render();
    });
    this.filteredMindmaps.forEach((mindmap) => {
      const mindmapItem = mindmapList.createDiv({ cls: "mindmap-item" });
      mindmapItem.style.display = "flex";
      mindmapItem.style.alignItems = "center";
      mindmapItem.style.padding = "8px";
      mindmapItem.style.border = "1px solid var(--background-modifier-border)";
      mindmapItem.style.borderRadius = "4px";
      mindmapItem.style.marginBottom = "4px";
      const checkbox = mindmapItem.createEl("input", { type: "checkbox" });
      checkbox.checked = this.selectedMindmaps.has(mindmap.id);
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          this.selectedMindmaps.add(mindmap.id);
        } else {
          this.selectedMindmaps.delete(mindmap.id);
        }
        this.render();
      });
      const info = mindmapItem.createDiv({ cls: "mindmap-info" });
      info.style.marginLeft = "10px";
      info.style.flex = "1";
      const name = info.createEl("div", {
        text: mindmap.name,
        cls: "mindmap-name"
      });
      name.style.fontWeight = "500";
      const details = info.createEl("div", {
        cls: "mindmap-details"
      });
      details.style.fontSize = "0.9em";
      details.style.color = "var(--text-muted)";
      const mainDetails = details.createEl("div", {
        text: `${mindmap.sourceCount} sources \u2022 Created ${new Date(mindmap.createdAt).toLocaleDateString()} \u2022 ${mindmap.metadata.llmProvider}`
      });
      if (mindmap.metadata.steepleCategories.length > 0) {
        const categories = details.createEl("div", {
          text: `Categories: ${mindmap.metadata.steepleCategories.join(", ")}`,
          cls: "mindmap-categories"
        });
        categories.style.fontSize = "0.8em";
        categories.style.marginTop = "2px";
        categories.style.fontStyle = "italic";
      }
      const previewBtn = mindmapItem.createEl("button", {
        text: "\u{1F441}\uFE0F",
        cls: "mod-muted"
      });
      previewBtn.style.marginLeft = "8px";
      previewBtn.style.padding = "4px 8px";
      previewBtn.title = "Preview mindmap structure";
      previewBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.showMindmapPreview(mindmap);
      });
    });
    container.createEl("h3", { text: "Combine Options" });
    new import_obsidian6.Setting(container).setName("Preserve Source Attribution").setDesc("Keep track of which sources contributed to each node").addToggle((toggle) => toggle.setValue(this.combineOptions.preserveSourceAttribution).onChange((value) => {
      this.combineOptions.preserveSourceAttribution = value;
    }));
    new import_obsidian6.Setting(container).setName("Deduplicate Source Links").setDesc('Remove duplicate source file references when combining nodes (e.g., same article under "Data Privacy" and "Data Protection")').addToggle((toggle) => toggle.setValue(this.combineOptions.deduplicateSourceLinks).onChange((value) => {
      this.combineOptions.deduplicateSourceLinks = value;
    }));
    new import_obsidian6.Setting(container).setName("Maintain STEEPLE Structure").setDesc("Organize combined content using STEEPLE framework").addToggle((toggle) => toggle.setValue(this.combineOptions.maintainSteepleStructure).onChange((value) => {
      this.combineOptions.maintainSteepleStructure = value;
    }));
    new import_obsidian6.Setting(container).setName("Enable Semantic Matching").setDesc("Use fuzzy/semantic matching to identify similar concepts (experimental)").addToggle((toggle) => toggle.setValue(this.combineOptions.enableSemanticDeduplication).onChange((value) => {
      this.combineOptions.enableSemanticDeduplication = value;
      this.render();
    }));
    if (this.combineOptions.enableSemanticDeduplication) {
      new import_obsidian6.Setting(container).setName("Similarity Threshold").setDesc("How similar nodes must be to be considered duplicates (0.0 = different, 1.0 = identical)").addSlider((slider) => slider.setLimits(0.3, 0.9, 0.1).setValue(this.combineOptions.maxSimilarityThreshold).setDynamicTooltip().onChange((value) => {
        this.combineOptions.maxSimilarityThreshold = value;
      }));
    }
    new import_obsidian6.Setting(container).setName("Duplicate Resolution").setDesc("How to handle duplicate or similar nodes").addDropdown((dropdown) => dropdown.addOption("exact_match" /* EXACT_MATCH */, "Exact Match - Only merge identical labels").addOption("semantic_similarity" /* SEMANTIC_SIMILARITY */, "Semantic Similarity - Use fuzzy matching").addOption("manual_review" /* MANUAL_REVIEW */, "Manual Review - Keep all duplicates for review").setValue(this.combineOptions.conflictResolutionStrategy).onChange((value) => {
      this.combineOptions.conflictResolutionStrategy = value;
    }));
    const actionContainer = container.createDiv({ cls: "modal-button-container" });
    actionContainer.style.display = "flex";
    actionContainer.style.justifyContent = "flex-end";
    actionContainer.style.gap = "10px";
    actionContainer.style.marginTop = "20px";
    const cancelBtn = actionContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());
    const combineBtn = actionContainer.createEl("button", {
      text: `Combine ${this.selectedMindmaps.size} Mindmaps`,
      cls: "mod-cta"
    });
    combineBtn.disabled = this.selectedMindmaps.size < 2;
    combineBtn.addEventListener("click", () => this.performCombine());
  }
  async performCombine() {
    if (this.selectedMindmaps.size < 2) {
      new import_obsidian6.Notice("Please select at least 2 mindmaps to combine");
      return;
    }
    try {
      const combineBtn = this.contentEl.querySelector(".mod-cta");
      combineBtn.disabled = true;
      combineBtn.textContent = "Combining...";
      const mindmapIds = Array.from(this.selectedMindmaps);
      const combinedName = this.combinedName || this.generateAutoCombinedName();
      console.log(`Combining ${mindmapIds.length} mindmaps:`, mindmapIds);
      const combinedFilePath = await this.plugin.persistenceService.combineMindmaps(
        mindmapIds,
        combinedName,
        this.combineOptions
      );
      new import_obsidian6.Notice(`Successfully combined mindmaps! Saved as: ${combinedFilePath}`);
      this.close();
      const file = this.app.vault.getAbstractFileByPath(combinedFilePath);
      if (file) {
        const leaf = this.app.workspace.getUnpinnedLeaf();
        await leaf.openFile(file);
      }
    } catch (error) {
      console.error("Failed to combine mindmaps:", error);
      new import_obsidian6.Notice(`Failed to combine mindmaps: ${error.message}`);
      const combineBtn = this.contentEl.querySelector(".mod-cta");
      combineBtn.disabled = false;
      combineBtn.textContent = `Combine ${this.selectedMindmaps.size} Mindmaps`;
    }
  }
  generateAutoCombinedName() {
    const selectedMindmaps = this.allMindmaps.filter((m) => this.selectedMindmaps.has(m.id));
    const totalSources = selectedMindmaps.reduce((sum, m) => sum + m.sourceCount, 0);
    const date = new Date().toLocaleDateString();
    return `Combined Analysis (${selectedMindmaps.length} mindmaps, ${totalSources} sources) - ${date}`;
  }
  showMindmapPreview(mindmap) {
    const previewModal = new MindmapPreviewModal(this.app, mindmap);
    previewModal.open();
  }
};
var MindmapPreviewModal = class extends import_obsidian6.Modal {
  constructor(app, mindmap) {
    super(app);
    this.mindmap = mindmap;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: `Preview: ${this.mindmap.name}` });
    const details = contentEl.createDiv({ cls: "mindmap-preview-details" });
    details.style.marginBottom = "15px";
    details.style.padding = "10px";
    details.style.background = "var(--background-secondary)";
    details.style.borderRadius = "4px";
    details.createEl("p", { text: `Created: ${new Date(this.mindmap.createdAt).toLocaleString()}` });
    details.createEl("p", { text: `Sources: ${this.mindmap.sourceCount}` });
    details.createEl("p", { text: `Model: ${this.mindmap.metadata.llmProvider} (${this.mindmap.metadata.model})` });
    details.createEl("p", { text: `Categories: ${this.mindmap.metadata.steepleCategories.join(", ")}` });
    const structure = contentEl.createDiv({ cls: "mindmap-structure-preview" });
    structure.createEl("h3", { text: "Structure Preview" });
    const nodeList = structure.createDiv({ cls: "node-list" });
    nodeList.style.maxHeight = "400px";
    nodeList.style.overflowY = "auto";
    nodeList.style.border = "1px solid var(--background-modifier-border)";
    nodeList.style.padding = "10px";
    const rootNodes = this.mindmap.structure.rootNodes.slice(0, 3);
    const nodeMap = new Map(this.mindmap.structure.nodes.map((n) => [n.id, n]));
    rootNodes.forEach((rootId) => {
      const rootNode = nodeMap.get(rootId);
      if (rootNode) {
        this.renderPreviewNode(nodeList, rootNode, nodeMap, 0);
      }
    });
    const closeBtn = contentEl.createEl("button", { text: "Close", cls: "mod-cta" });
    closeBtn.style.marginTop = "15px";
    closeBtn.addEventListener("click", () => this.close());
  }
  renderPreviewNode(container, node, nodeMap, depth) {
    const nodeEl = container.createDiv({ cls: "preview-node" });
    nodeEl.style.marginLeft = `${depth * 20}px`;
    nodeEl.style.marginBottom = "4px";
    const prefix = depth === 0 ? "\u{1F4CA}" : depth === 1 ? "\u{1F4C1}" : depth === 2 ? "\u{1F4C4}" : "\u2022";
    nodeEl.createEl("span", { text: `${prefix} ${node.label}` });
    if (node.sourceNotes && node.sourceNotes.length > 0) {
      const sources = nodeEl.createEl("small", {
        text: ` (${node.sourceNotes.length} sources)`,
        cls: "mod-muted"
      });
      sources.style.marginLeft = "8px";
    }
    const children = node.children.slice(0, 3);
    children.forEach((childId) => {
      const childNode = nodeMap.get(childId);
      if (childNode && depth < 2) {
        this.renderPreviewNode(container, childNode, nodeMap, depth + 1);
      }
    });
    if (node.children.length > 3) {
      const more = container.createDiv({ cls: "preview-more" });
      more.style.marginLeft = `${(depth + 1) * 20}px`;
      more.style.color = "var(--text-muted)";
      more.style.fontStyle = "italic";
      more.textContent = `... and ${node.children.length - 3} more`;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  llmProvider: "claude",
  apiKey: "",
  model: "claude-3-5-sonnet-latest",
  maxTokens: 4e3,
  includeContent: true,
  tagWeighting: "high",
  autoSave: true,
  outputFormat: "both",
  enableMultiParent: true,
  maxSourceFiles: 50,
  mindmapsFolder: "AI Mindmaps",
  saveFormat: "both"
};
var AIMindmapPlugin = class extends import_obsidian7.Plugin {
  async onload() {
    await this.loadSettings();
    this.contentAggregator = new ContentAggregator(this.app);
    this.llmService = new LLMService(this.settings);
    this.mindmapGenerator = new MindmapGenerator();
    this.persistenceService = new MindmapPersistenceService(this.app, this);
    await this.persistenceService.initialize();
    this.registerView(
      VIEW_TYPE_MINDMAP,
      (leaf) => new MindmapView(leaf, this)
    );
    this.registerView(
      VIEW_TYPE_VISUAL_MINDMAP,
      (leaf) => new VisualMindmapView(leaf, this)
    );
    const ribbonIconEl = this.addRibbonIcon("brain-circuit", "AI Mindmap Generator", (evt) => {
      this.openSourceSelector();
    });
    const combineRibbonEl = this.addRibbonIcon("link", "Combine Mindmaps", (evt) => {
      this.openMindmapCombiner();
    });
    this.addCommand({
      id: "generate-mindmap-from-selection",
      name: "Generate mindmap from selected files",
      callback: () => {
        this.openSourceSelector();
      }
    });
    this.addCommand({
      id: "generate-mindmap-from-current",
      name: "Generate mindmap from current note",
      editorCallback: (editor, view) => {
        this.generateFromCurrentNote(view);
      }
    });
    this.addCommand({
      id: "generate-mindmap-from-tag",
      name: "Generate mindmap from tag",
      callback: () => {
        this.openTagSelector();
      }
    });
    this.addCommand({
      id: "open-visual-mindmap",
      name: "Open visual mindmap view",
      callback: () => {
        this.activateVisualMindmapView();
      }
    });
    this.addCommand({
      id: "combine-mindmaps",
      name: "Combine multiple mindmaps",
      callback: () => {
        this.openMindmapCombiner();
      }
    });
    this.addSettingTab(new AIMindmapSettingTab(this.app, this));
    console.log("AI Mindmap Generator plugin loaded");
  }
  onunload() {
    console.log("AI Mindmap Generator plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.llmService.updateSettings(this.settings);
  }
  openSourceSelector() {
    new SourceSelectorModal(this.app, this, (selection) => {
      this.generateMindmapFromSelection(selection);
    }).open();
  }
  async generateFromCurrentNote(view) {
    if (!view) {
      new import_obsidian7.Notice("No active note found");
      return;
    }
    const file = view.file;
    if (!file) {
      new import_obsidian7.Notice("Current view has no associated file");
      return;
    }
    const selection = {
      files: [file.path],
      folders: [],
      tags: [],
      includeSubfolders: false,
      contentPreview: ""
    };
    await this.generateMindmapFromSelection(selection);
  }
  async openTagSelector() {
    new import_obsidian7.Notice("Tag selector coming in next version!");
  }
  async openMindmapCombiner() {
    try {
      console.log("Opening mindmap combiner modal...");
      const savedMindmaps = await this.persistenceService.getAllMindmaps();
      console.log(`Found ${savedMindmaps.length} saved mindmaps`);
      if (savedMindmaps.length < 2) {
        new import_obsidian7.Notice("You need at least 2 saved mindmaps to combine. Generate more mindmaps first!");
        return;
      }
      const modal = new MindmapCombinerModal(this.app, this);
      modal.open();
      console.log("Mindmap combiner modal opened successfully");
    } catch (error) {
      console.error("Failed to open mindmap combiner:", error);
      new import_obsidian7.Notice(`Failed to open mindmap combiner: ${error.message}`);
    }
  }
  async generateMindmapFromSelection(selection) {
    if (!this.settings.apiKey) {
      new import_obsidian7.Notice("Please configure your API key in settings first");
      return;
    }
    try {
      new import_obsidian7.Notice("Analyzing content and generating mindmap...");
      const processedContent = await this.contentAggregator.processSelection(selection);
      if (processedContent.length === 0) {
        new import_obsidian7.Notice("No content found in selection");
        return;
      }
      const llmResponse = await this.llmService.generateMindmapStructure(
        processedContent,
        this.extractAllTags(processedContent)
      );
      if (!llmResponse.success) {
        new import_obsidian7.Notice(`Failed to generate mindmap: ${llmResponse.error}`);
        return;
      }
      const mindmapStructure = await this.mindmapGenerator.buildStructure(
        llmResponse.structure,
        processedContent,
        this.settings
      );
      const sourceFiles = processedContent.map((content) => content.filePath);
      await this.displayMindmap(mindmapStructure, sourceFiles);
      new import_obsidian7.Notice(`Mindmap generated successfully! (${processedContent.length} sources processed)`);
    } catch (error) {
      console.error("Error generating mindmap:", error);
      new import_obsidian7.Notice(`Error: ${error.message}`);
    }
  }
  extractAllTags(processedContent) {
    const allTags = /* @__PURE__ */ new Set();
    processedContent.forEach((content) => {
      var _a;
      (_a = content.tags) == null ? void 0 : _a.forEach((tag) => allTags.add(tag));
    });
    return Array.from(allTags);
  }
  async displayMindmap(structure, sourceFiles = []) {
    if (this.settings.outputFormat === "note" || this.settings.outputFormat === "both") {
      await this.createMindmapNote(structure);
    }
    if (this.settings.outputFormat === "view" || this.settings.outputFormat === "both") {
      await this.openVisualMindmapView(structure, sourceFiles);
    }
  }
  async createMindmapNote(structure) {
    const fileName = `AI Mindmap - ${new Date().toISOString().slice(0, 19).replace(/:/g, "-")}.md`;
    const markdownContent = this.mindmapGenerator.convertToMarkdown(structure);
    await this.app.vault.create(fileName, markdownContent);
    if (this.settings.autoSave) {
      new import_obsidian7.Notice(`Mindmap saved as: ${fileName}`);
    }
  }
  async openVisualMindmapView(structure, sourceFiles = []) {
    const leaf = this.app.workspace.getLeaf(true);
    await leaf.setViewState({
      type: VIEW_TYPE_VISUAL_MINDMAP,
      state: {
        mindmapData: structure,
        sourceFiles
      }
    });
    this.app.workspace.revealLeaf(leaf);
  }
  async activateVisualMindmapView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_VISUAL_MINDMAP);
    if (leaves.length > 0) {
      this.app.workspace.revealLeaf(leaves[0]);
    } else {
      const leaf = this.app.workspace.getLeaf(true);
      await leaf.setViewState({
        type: VIEW_TYPE_VISUAL_MINDMAP
      });
      this.app.workspace.revealLeaf(leaf);
    }
  }
};
var AIMindmapSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Mindmap Generator Settings" });
    new import_obsidian7.Setting(containerEl).setName("LLM Provider").setDesc("Choose your preferred language model provider").addDropdown((dropdown) => dropdown.addOption("claude", "Anthropic Claude").addOption("openai", "OpenAI GPT").addOption("custom", "Custom API").setValue(this.plugin.settings.llmProvider).onChange(async (value) => {
      this.plugin.settings.llmProvider = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian7.Setting(containerEl).setName("API Key").setDesc("Your LLM provider API key (stored securely)").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    if (this.plugin.settings.llmProvider === "claude") {
      new import_obsidian7.Setting(containerEl).setName("Model").setDesc("Claude model to use for mindmap generation").addDropdown((dropdown) => dropdown.addOption("claude-3-5-sonnet-latest", "Claude 3.5 Sonnet (Latest)").addOption("claude-3-5-haiku-latest", "Claude 3.5 Haiku (Latest)").setValue(this.plugin.settings.model).onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.plugin.saveSettings();
      }));
    } else if (this.plugin.settings.llmProvider === "openai") {
      new import_obsidian7.Setting(containerEl).setName("Model").setDesc("OpenAI model to use for mindmap generation").addDropdown((dropdown) => dropdown.addOption("gpt-4-turbo-preview", "GPT-4 Turbo").addOption("gpt-4", "GPT-4").addOption("gpt-3.5-turbo", "GPT-3.5 Turbo").setValue(this.plugin.settings.model).onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.llmProvider === "custom") {
      new import_obsidian7.Setting(containerEl).setName("Custom API URL").setDesc("Base URL for your custom LLM API").addText((text) => text.setPlaceholder("https://api.example.com/v1").setValue(this.plugin.settings.customApiUrl || "").onChange(async (value) => {
        this.plugin.settings.customApiUrl = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian7.Setting(containerEl).setName("Max Tokens").setDesc("Maximum tokens for LLM response").addText((text) => text.setPlaceholder("4000").setValue(this.plugin.settings.maxTokens.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.maxTokens = numValue;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "Tag Integration" });
    new import_obsidian7.Setting(containerEl).setName("Tag Weighting").setDesc("How heavily to weight existing tags in mindmap generation").addDropdown((dropdown) => dropdown.addOption("high", "High - Tags strongly influence structure").addOption("medium", "Medium - Balanced with content analysis").addOption("low", "Low - Tags provide minor guidance").setValue(this.plugin.settings.tagWeighting).onChange(async (value) => {
      this.plugin.settings.tagWeighting = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Enable Multi-parent Connections").setDesc("Allow nodes to connect to multiple parent nodes based on shared tags").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableMultiParent).onChange(async (value) => {
      this.plugin.settings.enableMultiParent = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Output Options" });
    new import_obsidian7.Setting(containerEl).setName("Output Format").setDesc("How to display generated mindmaps").addDropdown((dropdown) => dropdown.addOption("note", "Create new note only").addOption("view", "Open in mindmap view only").addOption("both", "Both note and view").setValue(this.plugin.settings.outputFormat).onChange(async (value) => {
      this.plugin.settings.outputFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Auto-save Generated Maps").setDesc("Automatically save mindmaps as notes").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSave).onChange(async (value) => {
      this.plugin.settings.autoSave = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Max Source Files").setDesc("Maximum number of files to process in one mindmap").addText((text) => text.setPlaceholder("50").setValue(this.plugin.settings.maxSourceFiles.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.maxSourceFiles = numValue;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "Mindmap Storage" });
    new import_obsidian7.Setting(containerEl).setName("Mindmaps Folder").setDesc("Folder in your vault to save mindmaps (will be created if it doesn't exist)").addText((text) => text.setPlaceholder("AI Mindmaps").setValue(this.plugin.settings.mindmapsFolder).onChange(async (value) => {
      this.plugin.settings.mindmapsFolder = value.trim() || "AI Mindmaps";
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Save Format").setDesc("How to save mindmaps").addDropdown((dropdown) => dropdown.addOption("markdown", "Markdown files only (recommended)").addOption("both", "Markdown + metadata backup").setValue(this.plugin.settings.saveFormat).onChange(async (value) => {
      this.plugin.settings.saveFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Test API Connection").setDesc("Verify your API key and connection").addButton((button) => button.setButtonText("Test Connection").setCta().onClick(async () => {
      button.setButtonText("Testing...");
      try {
        const testResult = await this.plugin.llmService.testConnection();
        if (testResult.success) {
          new import_obsidian7.Notice("\u2705 API connection successful!");
        } else {
          new import_obsidian7.Notice(`\u274C Connection failed: ${testResult.error}`);
        }
      } catch (error) {
        new import_obsidian7.Notice(`\u274C Connection error: ${error.message}`);
      }
      button.setButtonText("Test Connection");
    }));
  }
};
